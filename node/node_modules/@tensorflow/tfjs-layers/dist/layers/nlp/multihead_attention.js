/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 *  TFJS-based multi-head attention layer.
 */
/* Original source: keras/layers/attention/multi_head_attention.py */
import { serialization } from '@tensorflow/tfjs-core';
import { Layer } from '../../engine/topology';
import { NotImplementedError } from '../../errors';
/**
 * Builds einsum equations for the attention computation.
 *
 * Query, key, value inputs after projection are expected to have the shape as:
 * `(bs, <non-attention dims>, <attention dims>, num_heads, channels)`.
 * `bs` and `<non-attention dims>` are treated as `<batch dims>`.
 *
 * The attention operations can be generalized:
 * (1) Query-key dot product:
 * `(<batch dims>, <query attention dims>, num_heads, channels), (<batch dims>,
 * <key attention dims>, num_heads, channels) -> (<batch dims>,
 * num_heads, <query attention dims>, <key attention dims>)`
 * (2) Combination:
 * `(<batch dims>, num_heads, <query attention dims>, <key attention dims>),
 * (<batch dims>, <value attention dims>, num_heads, channels) -> (<batch
 * dims>, <query attention dims>, num_heads, channels)`
 *
 * @param rank Rank of query, key, value tensors.
 * @param attnAxes Array of axes, `[-1, rank)`,
 *    that attention will be applied to.
 * @returns Einsum equations.
 */
function buildAttentionEquation(rank, attnAxes) {
    throw new NotImplementedError('Not implemented yet.');
}
/**
 * Builds an einsum equation for projections inside multi-head attention.
 */
function buildProjectionEquation(freeDims, boundDims, outputDims) {
    throw new NotImplementedError('Not implemented yet.');
}
function getOutputShape(outputRank, knownLastDims) {
    throw new NotImplementedError('Not implemented yet.');
}
/**
 * MultiHeadAttention layer.
 *
 * This is an implementation of multi-headed attention as described in the
 * paper "Attention is all you Need" (Vaswani et al., 2017).
 * If `query`, `key,` `value` are the same, then
 * this is self-attention. Each timestep in `query` attends to the
 * corresponding sequence in `key`, and returns a fixed-width vector.
 *
 * This layer first projects `query`, `key` and `value`. These are
 * (effectively) a list of tensors of length `numAttentionHeads`, where the
 * corresponding shapes are `(batchSize, <query dimensions>, keyDim)`,
 * `(batchSize, <key/value dimensions>, keyDim)`,
 * `(batchSize, <key/value dimensions>, valueDim)`.
 *
 * Then, the query and key tensors are dot-producted and scaled. These are
 * softmaxed to obtain attention probabilities. The value tensors are then
 * interpolated by these probabilities, then concatenated back to a single
 * tensor.
 *
 * Finally, the result tensor with the last dimension as valueDim can take an
 * linear projection and return.
 *
 * When using `MultiHeadAttention` inside a custom layer, the custom layer must
 * implement its own `build()` method and call `MultiHeadAttention`'s
 * `buildFromSignature()` there.
 * This enables weights to be restored correctly when the model is loaded.
 *
 * Examples:
 *
 * Performs 1D cross-attention over two sequence inputs with an attention mask.
 * Returns the additional attention weights over heads.
 *
 * const layer = new MultiHeadAttention({numHeads: 2, keyDim: 2});
 * const target = tf.input({shape: [8, 16]});
 * const source = tf.input({shape: [4, 16]});
 * const outputTensor, weights = layer.callAndReturnAttentionScores(
 *     target, {value: source});
 * console.log(outputTensor.shape);  // [null, 8, 16]
 * console.log(weights.shape);  // [null, 2, 8, 4]
 *
 * Performs 2D self-attention over a 5D input tensor on axes 2 and 3.
 *
 * const layer = new MultiHeadAttention({
 *    numHeads: 2, keyDim: 2, attentionAxes: [2, 3]});
 * const inputTensor = tf.input({shape: [5, 3, 4, 16]});
 * const outputTensor = layer.call(inputTensor, {value: inputTensor});
 * console.log(outputTensor.shape);  // [null, 5, 3, 4, 16]
 *
 * Returns:
 *    attentionOutput: The result of the computation, of shape `(B, T, E)`,
 *        where `T` is for target sequence shapes and `E` is the query input
 *        last dimension if `outputShape` is `None`. Otherwise, the
 *        multi-head outputs are projected to the shape specified by
 *        `outputShape`.
 *    attentionScores: multi-head attention coefficients over attention axes.
 */
class MultiHeadAttention extends Layer {
    constructor(args) {
        super(args);
        throw new NotImplementedError('Not implemented yet.');
    }
    getConfig() {
        throw new NotImplementedError('Not implemented yet.');
    }
    static fromConfig(cls, config) {
        throw new NotImplementedError('Not implemented yet.');
    }
    /**
     * Builds layers and variables.
     *
     * Once the method is called, this.builtFromSignature will be set to true.
     */
    buildFromSignature(query, value, key) {
        throw new NotImplementedError(`Not implemented yet. Uses ${buildProjectionEquation}, ${getOutputShape},
       ${this.getCommonKwargsForSublayer}, ${this.buildAttention},
       ${this.makeOutputDense}.`);
    }
    getCommonKwargsForSublayer() {
        throw new NotImplementedError('Not implemented yet.');
    }
    /**
     * Builds the output projection matrix.
     *
     * @param freeDims Number of free dimensions for einsum equation building.
     * @param commonKwargs Common keyword arguments for einsum layer.
     * @param name Name for the projection layer.
     * @returns Projection layer.
     */
    makeOutputDense(freeDims, commonKwargs, name) {
        throw new NotImplementedError('Not implemented yet.');
    }
    /**
     * Builds multi-head dot-product attention computations.
     *
     * This function builds attributes necessary for `_compute_attention` to
     * customize attention computation to replace the default dot-product
     * attention.
     *
     * @param rank The rank of query, key, value tensors.
     */
    buildAttention(rank) {
        throw new NotImplementedError(`Not implemented yet. Uses ${buildAttentionEquation}.`);
    }
    maskedSoftmax(attentionScores, attentionMask) {
        throw new NotImplementedError('Not implemented yet.');
    }
    /**
     * Applies Dot-product attention with query, key, value tensors.
     *
     * This function defines the computation inside `call` with projected
     * multi-head Q, K, V inputs. Users can override this function for
     * customized attention implementation.
     *
     * @param query Projected query `Tensor` of shape `(B, T, N, key_dim)`.
     * @param key  Projected key `Tensor` of shape `(B, S, N, key_dim)`.
     * @param value Projected value `Tensor` of shape `(B, S, N, value_dim)`.
     * @param attentionMask A boolean mask of shape `(B, T, S)`, that prevents
     *    attention to certain positions. It is generally not needed if
     *    the `query` and `value` (and/or `key`) are masked.
     * @param training Boolean indicating whether the layer should behave
     *    in training mode (adding dropout) or in inference mode (doing
     *    nothing).
     * @returns attentionOutput: Multi-headed outputs of attention computation.
     * @returns attentionScores: Multi-headed attention weights.
     */
    computeAttention(query, key, value, attentionMask, training) {
        throw new NotImplementedError(`Not implemented yet. Uses ${this.maskedSoftmax}.`);
    }
    call(query, kwargs) {
        return this.callAndReturnAttentionScores(query, kwargs)[0];
    }
    /**
     * Exactly like `call` except also returns the attention scores.
     */
    callAndReturnAttentionScores(query, kwargs) {
        throw new NotImplementedError(`Not implemented yet. Uses ${this.buildFromSignature},
       ${this.computeAttentionMask}, ${this.computeAttention}.`);
    }
    /**
     * Computes the attention mask.
     *
     * * The `query`'s mask is reshaped from [B, T] to [B, T, 1].
     * * The `value`'s mask is reshaped from [B, S] to [B, 1, S].
     * * The `key`'s mask is reshaped from [B, S] to [B, 1, S]. The `key`'s
     *   mask is ignored if `key` is `None` or if `key is value`.
     * * If `useCausalMask=true`, then the causal mask is computed. Its shape
     *   is [1, T, S].
     *
     * All defined masks are merged using a logical AND operation (`&`).
     *
     * In general, if the `query` and `value` are masked, then there is no need
     * to define the `attentionMask`.
     *
     * @param query Projected query `Tensor` of shape `(B, T, N, key_dim)`.
     * @param key  Projected key `Tensor` of shape `(B, S, N, key_dim)`.
     * @param value Projected value `Tensor` of shape `(B, S, N, value_dim)`.
     * @param attentionMask A boolean mask of shape `(B, T, S)`, that prevents
     *    attention to certain positions.
     * @param useCausalMask  A boolean to indicate whether to apply a causal
     *    mask to prevent tokens from attending to future tokens (e.g.,
     *    used in a decoder Transformer).
     * @returns attentionMask: A boolean mask of shape `(B, T, S)`, that prevents
     *    attention to certain positions, based on the Keras masks of the
     *    `query`, `key`, `value`, and `attentionMask` tensors, and the
     *    causal mask if `useCausalMask=true`.
     */
    computeAttentionMask(query, value, key, attentionMask, useCausalMask) {
        throw new NotImplementedError(`Not implemented yet. Uses ${this.computeCasualMask}`);
    }
    /**
     * Computes a causal mask (e.g., for masked self-attention layers).
     *
     * For example, if query and value both contain sequences of length 4,
     * this function returns a boolean `Tensor` equal to:
     *
     * ```
     * [[[true,  false, false, false],
     *   [true,  true,  false, false],
     *   [true,  true,  true,  false],
     *   [true,  true,  true,  true]]]
     * ```
     *
     * @param query query `Tensor` of shape `(B, T, ...)`.
     * @param value value `Tensor` of shape `(B, S, ...)` (defaults to query).
     * @returns mask: A boolean `Tensor` of shape [1, T, S] containing a lower
     *    triangular matrix of shape [T, S].
     */
    computeCasualMask(query, value) {
        throw new NotImplementedError('Not implemented yet.');
    }
    /**
     *
     * @param inputShapes A list of [queryShape, valueShape] or
     *    [queryShape, valueShape, keyShape]. If no keyShape provided, valueShape
     *    is assumed as the keyShape.
     */
    computeOutputShape(inputShapes) {
        throw new NotImplementedError('Not implemented yet.');
    }
}
/** @nocollapse */
MultiHeadAttention.className = 'MultiHeadAttention';
export { MultiHeadAttention };
serialization.registerClass(MultiHeadAttention);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGloZWFkX2F0dGVudGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvbmxwL211bHRpaGVhZF9hdHRlbnRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUg7O0dBRUc7QUFFSCxxRUFBcUU7QUFDckUsT0FBTyxFQUE4QixhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUdsRixPQUFPLEVBQUUsS0FBSyxFQUFhLE1BQU0sdUJBQXVCLENBQUM7QUFDekQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBTW5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkc7QUFDSCxTQUFTLHNCQUFzQixDQUM3QixJQUFZLEVBQUUsUUFBa0I7SUFFaEMsTUFBTSxJQUFJLG1CQUFtQixDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyx1QkFBdUIsQ0FDOUIsUUFBZ0IsRUFBRSxTQUFpQixFQUFFLFVBQWtCO0lBRXZELE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FDckIsVUFBa0IsRUFBRSxhQUErQjtJQUVuRCxNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBMkhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdERztBQUNILE1BQWEsa0JBQW1CLFNBQVEsS0FBSztJQUkzQyxZQUFZLElBQTRCO1FBQ3RDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNaLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFUSxTQUFTO1FBQ2hCLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxNQUFNLENBQVUsVUFBVSxDQUN4QixHQUE2QyxFQUM3QyxNQUFnQztRQUVoQyxNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLGtCQUFrQixDQUFDLEtBQWEsRUFBRSxLQUFhLEVBQUUsR0FBWTtRQUNuRSxNQUFNLElBQUksbUJBQW1CLENBQzNCLDZCQUE2Qix1QkFBdUIsS0FBSyxjQUFjO1NBQ3BFLElBQUksQ0FBQywwQkFBMEIsS0FBSyxJQUFJLENBQUMsY0FBYztTQUN2RCxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU8sMEJBQTBCO1FBQ2hDLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ssZUFBZSxDQUNyQixRQUFnQixFQUFFLFlBQW9CLEVBQUUsSUFBYTtRQUVyRCxNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSyxjQUFjLENBQUMsSUFBWTtRQUNqQyxNQUFNLElBQUksbUJBQW1CLENBQzNCLDZCQUE2QixzQkFBc0IsR0FBRyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVPLGFBQWEsQ0FDbkIsZUFBdUIsRUFBRSxhQUFzQjtRQUUvQyxNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNLLGdCQUFnQixDQUN0QixLQUFhLEVBQ2IsR0FBVyxFQUNYLEtBQWEsRUFDYixhQUFzQixFQUN0QixRQUFrQjtRQUVsQixNQUFNLElBQUksbUJBQW1CLENBQzNCLDZCQUE2QixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRVEsSUFBSSxDQUNYLEtBQWEsRUFBRSxNQUFpQztRQUVoRCxPQUFPLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOztPQUVHO0lBQ0gsNEJBQTRCLENBQzFCLEtBQWEsRUFBRSxNQUFpQztRQUVoRCxNQUFNLElBQUksbUJBQW1CLENBQzNCLDZCQUE2QixJQUFJLENBQUMsa0JBQWtCO1NBQ2pELElBQUksQ0FBQyxvQkFBb0IsS0FBSyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJHO0lBQ0ssb0JBQW9CLENBQzFCLEtBQWEsRUFDYixLQUFhLEVBQ2IsR0FBWSxFQUNaLGFBQXNCLEVBQ3RCLGFBQXVCO1FBRXZCLE1BQU0sSUFBSSxtQkFBbUIsQ0FDM0IsNkJBQTZCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNLLGlCQUFpQixDQUFDLEtBQWEsRUFBRSxLQUFjO1FBQ3JELE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNNLGtCQUFrQixDQUN6QixXQUFtRDtRQUVuRCxNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUN4RCxDQUFDOztBQTNMRCxrQkFBa0I7QUFDRiw0QkFBUyxHQUFHLG9CQUFvQixDQUFDO1NBRnRDLGtCQUFrQjtBQThML0IsYUFBYSxDQUFDLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqICBURkpTLWJhc2VkIG11bHRpLWhlYWQgYXR0ZW50aW9uIGxheWVyLlxuICovXG5cbi8qIE9yaWdpbmFsIHNvdXJjZToga2VyYXMvbGF5ZXJzL2F0dGVudGlvbi9tdWx0aV9oZWFkX2F0dGVudGlvbi5weSAqL1xuaW1wb3J0IHsgVGVuc29yLCBUZW5zb3IxRCwgVGVuc29yMkQsIHNlcmlhbGl6YXRpb24gfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQgeyBDb25zdHJhaW50SWRlbnRpZmllciB9IGZyb20gJy4uLy4uL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7IExheWVyLCBMYXllckFyZ3MgfSBmcm9tICcuLi8uLi9lbmdpbmUvdG9wb2xvZ3knO1xuaW1wb3J0IHsgTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBJbml0aWFsaXplcklkZW50aWZpZXIgfSBmcm9tICcuLi8uLi9pbml0aWFsaXplcnMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi8uLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7IFJlZ3VsYXJpemVySWRlbnRpZmllciB9IGZyb20gJy4uLy4uL3JlZ3VsYXJpemVycyc7XG5pbXBvcnQgeyBLd2FyZ3MgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbi8qKlxuICogQnVpbGRzIGVpbnN1bSBlcXVhdGlvbnMgZm9yIHRoZSBhdHRlbnRpb24gY29tcHV0YXRpb24uXG4gKlxuICogUXVlcnksIGtleSwgdmFsdWUgaW5wdXRzIGFmdGVyIHByb2plY3Rpb24gYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNoYXBlIGFzOlxuICogYChicywgPG5vbi1hdHRlbnRpb24gZGltcz4sIDxhdHRlbnRpb24gZGltcz4sIG51bV9oZWFkcywgY2hhbm5lbHMpYC5cbiAqIGBic2AgYW5kIGA8bm9uLWF0dGVudGlvbiBkaW1zPmAgYXJlIHRyZWF0ZWQgYXMgYDxiYXRjaCBkaW1zPmAuXG4gKlxuICogVGhlIGF0dGVudGlvbiBvcGVyYXRpb25zIGNhbiBiZSBnZW5lcmFsaXplZDpcbiAqICgxKSBRdWVyeS1rZXkgZG90IHByb2R1Y3Q6XG4gKiBgKDxiYXRjaCBkaW1zPiwgPHF1ZXJ5IGF0dGVudGlvbiBkaW1zPiwgbnVtX2hlYWRzLCBjaGFubmVscyksICg8YmF0Y2ggZGltcz4sXG4gKiA8a2V5IGF0dGVudGlvbiBkaW1zPiwgbnVtX2hlYWRzLCBjaGFubmVscykgLT4gKDxiYXRjaCBkaW1zPixcbiAqIG51bV9oZWFkcywgPHF1ZXJ5IGF0dGVudGlvbiBkaW1zPiwgPGtleSBhdHRlbnRpb24gZGltcz4pYFxuICogKDIpIENvbWJpbmF0aW9uOlxuICogYCg8YmF0Y2ggZGltcz4sIG51bV9oZWFkcywgPHF1ZXJ5IGF0dGVudGlvbiBkaW1zPiwgPGtleSBhdHRlbnRpb24gZGltcz4pLFxuICogKDxiYXRjaCBkaW1zPiwgPHZhbHVlIGF0dGVudGlvbiBkaW1zPiwgbnVtX2hlYWRzLCBjaGFubmVscykgLT4gKDxiYXRjaFxuICogZGltcz4sIDxxdWVyeSBhdHRlbnRpb24gZGltcz4sIG51bV9oZWFkcywgY2hhbm5lbHMpYFxuICpcbiAqIEBwYXJhbSByYW5rIFJhbmsgb2YgcXVlcnksIGtleSwgdmFsdWUgdGVuc29ycy5cbiAqIEBwYXJhbSBhdHRuQXhlcyBBcnJheSBvZiBheGVzLCBgWy0xLCByYW5rKWAsXG4gKiAgICB0aGF0IGF0dGVudGlvbiB3aWxsIGJlIGFwcGxpZWQgdG8uXG4gKiBAcmV0dXJucyBFaW5zdW0gZXF1YXRpb25zLlxuICovXG5mdW5jdGlvbiBidWlsZEF0dGVudGlvbkVxdWF0aW9uKFxuICByYW5rOiBudW1iZXIsIGF0dG5BeGVzOiBudW1iZXJbXVxuKTogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddIHtcbiAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG59XG5cbi8qKlxuICogQnVpbGRzIGFuIGVpbnN1bSBlcXVhdGlvbiBmb3IgcHJvamVjdGlvbnMgaW5zaWRlIG11bHRpLWhlYWQgYXR0ZW50aW9uLlxuICovXG5mdW5jdGlvbiBidWlsZFByb2plY3Rpb25FcXVhdGlvbihcbiAgZnJlZURpbXM6IG51bWJlciwgYm91bmREaW1zOiBudW1iZXIsIG91dHB1dERpbXM6IG51bWJlclxuKTogW3N0cmluZywgc3RyaW5nLCBudW1iZXJdIHtcbiAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldE91dHB1dFNoYXBlKFxuICBvdXRwdXRSYW5rOiBudW1iZXIsIGtub3duTGFzdERpbXM6IEl0ZXJhYmxlPG51bWJlcj5cbik6IFNoYXBlIHtcbiAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBNdWx0aUhlYWRBdHRlbnRpb25BcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIEludGVnZXIuIE51bWJlciBvZiBhdHRlbnRpb24gaGVhZHMuXG4gICAqL1xuICBudW1IZWFkczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJbnRlZ2VyLiBTaXplIG9mIGVhY2ggYXR0ZW50aW9uIGhlYWQgZm9yIHF1ZXJ5IGFuZCBrZXkuXG4gICAqL1xuICBrZXlEaW06IG51bWJlcjtcblxuICAvKipcbiAgICogSW50ZWdlci4gU2l6ZSBvZiBlYWNoIGF0dGVudGlvbiBoZWFkIGZvciB2YWx1ZS5cbiAgICogRGVmYXVsdHMgdG8gYGtleURpbWAuXG4gICAqL1xuICB2YWx1ZURpbT86IG51bWJlcjtcblxuICAvKipcbiAgICogRHJvcG91dCBwcm9iYWJpbGl0eS5cbiAgICogRGVmYXVsdHMgdG8gMC4wLlxuICAgKi9cbiAgZHJvcG91dD86IG51bWJlcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZGVuc2UgbGF5ZXJzIHVzZSBiaWFzIHZlY3RvcnMvbWF0cmljZXMuXG4gICAqIERlZmF1bHRzIHRvIHRydWUuXG4gICAqL1xuICB1c2VCaWFzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGV4cGVjdGVkIHNoYXBlIG9mIGFuIG91dHB1dCB0ZW5zb3IsIGJlc2lkZXMgdGhlIGJhdGNoXG4gICAqIGFuZCBzZXF1ZW5jZSBkaW1zLiBJZiBub3Qgc3BlY2lmaWVkLCBwcm9qZWN0cyBiYWNrIHRvIHRoZSBxdWVyeVxuICAgKiBmZWF0dXJlIGRpbSAodGhlIHF1ZXJ5IGlucHV0J3MgbGFzdCBkaW1lbnNpb24pLlxuICAgKi9cbiAgb3V0cHV0U2hhcGU/OiBTaGFwZTtcblxuICAvKipcbiAgICogQXhlcyBvdmVyIHdoaWNoIHRoZSBhdHRlbnRpb24gaXMgYXBwbGllZC4gYG51bGxgIG1lYW5zIGF0dGVudGlvbiBvdmVyXG4gICAqIGFsbCBheGVzLCBidXQgYmF0Y2gsIGhlYWRzLCBhbmQgZmVhdHVyZXMuXG4gICAqL1xuICBhdHRlbnRpb25BeGVzOiBudW1iZXJbXTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIGRlbnNlIGxheWVyIGtlcm5lbHMuXG4gICAqIERlZmF1bHRzIHRvIGBcImdsb3JvdFVuaWZvcm1cImAuXG4gICAqL1xuICBrZXJuZWxJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIGRlbnNlIGxheWVyIGJpYXNlcy5cbiAgICogRGVmYXVsdHMgdG8gYFwiemVyb3NcImAuXG4gICAqL1xuICBiaWFzSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZvciBkZW5zZSBsYXllciBrZXJuZWxzLlxuICAgKi9cbiAga2VybmVsUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZvciBkZW5zZSBsYXllciBiaWFzZXMuXG4gICAqL1xuICBiaWFzUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZvciBkZW5zZSBsYXllciBhY3Rpdml0eS5cbiAgICovXG4gIGFjdGl2aXR5UmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbnQgZm9yIGRlbnNlIGxheWVyIGtlcm5lbHMuXG4gICAqL1xuICBrZXJuZWxDb25zdHJhaW50PzogQ29uc3RyYWludElkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbnQgZm9yIGRlbnNlIGxheWVyIGtlcm5lbHMuXG4gICAqL1xuICBiaWFzQ29uc3RyYWludD86IENvbnN0cmFpbnRJZGVudGlmaWVyO1xufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTXVsdGlIZWFkQXR0ZW50aW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBRdWVyeSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFQsIGRpbSlgLlxuICAgKi9cblxuICAvKipcbiAgICogVmFsdWUgYFRlbnNvcmAgb2Ygc2hhcGUgYChCLCBTLCBkaW0pYC5cbiAgICovXG4gIHZhbHVlOiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIEtleSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFMsIGRpbSlgLiBJZiBub3QgZ2l2ZW4sIHdpbGwgdXNlIGB2YWx1ZWAgZm9yXG4gICAqIGJvdGggYGtleWAgYW5kIGB2YWx1ZWAsIHdoaWNoIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLlxuICAgKi9cbiAga2V5PzogVGVuc29yO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gbWFzayBvZiBzaGFwZSBgKEIsIFQsIFMpYCwgdGhhdCBwcmV2ZW50c1xuICAgKiBhdHRlbnRpb24gdG8gY2VydGFpbiBwb3NpdGlvbnMuIFRoZSBib29sZWFuIG1hc2sgc3BlY2lmaWVzIHdoaWNoXG4gICAqIHF1ZXJ5IGVsZW1lbnRzIGNhbiBhdHRlbmQgdG8gd2hpY2gga2V5IGVsZW1lbnRzLCAxIGluZGljYXRlc1xuICAgKiBhdHRlbnRpb24gYW5kIDAgaW5kaWNhdGVzIG5vIGF0dGVudGlvbi4gQnJvYWRjYXN0aW5nIGNhbiBoYXBwZW4gZm9yXG4gICAqIHRoZSBtaXNzaW5nIGJhdGNoIGRpbWVuc2lvbnMgYW5kIHRoZSBoZWFkIGRpbWVuc2lvbi5cbiAgICovXG4gIGF0dGVudGlvbk1hc2s/OiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBsYXllciBzaG91bGQgYmVoYXZlIGluIHRyYWluaW5nIG1vZGVcbiAgICogKGFkZGluZyBkcm9wb3V0KSBvciBpbiBpbmZlcmVuY2UgbW9kZSAobm8gZHJvcG91dCkuXG4gICAqIFdpbGwgZ28gd2l0aCBlaXRoZXIgdXNpbmcgdGhlIHRyYWluaW5nIG1vZGUgb2YgdGhlIHBhcmVudFxuICAgKiBsYXllci9tb2RlbCwgb3IgZmFsc2UgKGluZmVyZW5jZSkgaWYgdGhlcmUgaXMgbm8gcGFyZW50IGxheWVyLlxuICAgKi9cbiAgdHJhaW5pbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBhcHBseSBhIGNhdXNhbCBtYXNrIHRvIHByZXZlbnQgdG9rZW5zIGZyb20gYXR0ZW5kaW5nXG4gICAqIHRvIGZ1dHVyZSB0b2tlbnMgKGUuZy4sIHVzZWQgaW4gYSBkZWNvZGVyIFRyYW5zZm9ybWVyKS5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICB1c2VDYXVzYWxNYXNrPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBNdWx0aUhlYWRBdHRlbnRpb24gbGF5ZXIuXG4gKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBtdWx0aS1oZWFkZWQgYXR0ZW50aW9uIGFzIGRlc2NyaWJlZCBpbiB0aGVcbiAqIHBhcGVyIFwiQXR0ZW50aW9uIGlzIGFsbCB5b3UgTmVlZFwiIChWYXN3YW5pIGV0IGFsLiwgMjAxNykuXG4gKiBJZiBgcXVlcnlgLCBga2V5LGAgYHZhbHVlYCBhcmUgdGhlIHNhbWUsIHRoZW5cbiAqIHRoaXMgaXMgc2VsZi1hdHRlbnRpb24uIEVhY2ggdGltZXN0ZXAgaW4gYHF1ZXJ5YCBhdHRlbmRzIHRvIHRoZVxuICogY29ycmVzcG9uZGluZyBzZXF1ZW5jZSBpbiBga2V5YCwgYW5kIHJldHVybnMgYSBmaXhlZC13aWR0aCB2ZWN0b3IuXG4gKlxuICogVGhpcyBsYXllciBmaXJzdCBwcm9qZWN0cyBgcXVlcnlgLCBga2V5YCBhbmQgYHZhbHVlYC4gVGhlc2UgYXJlXG4gKiAoZWZmZWN0aXZlbHkpIGEgbGlzdCBvZiB0ZW5zb3JzIG9mIGxlbmd0aCBgbnVtQXR0ZW50aW9uSGVhZHNgLCB3aGVyZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgc2hhcGVzIGFyZSBgKGJhdGNoU2l6ZSwgPHF1ZXJ5IGRpbWVuc2lvbnM+LCBrZXlEaW0pYCxcbiAqIGAoYmF0Y2hTaXplLCA8a2V5L3ZhbHVlIGRpbWVuc2lvbnM+LCBrZXlEaW0pYCxcbiAqIGAoYmF0Y2hTaXplLCA8a2V5L3ZhbHVlIGRpbWVuc2lvbnM+LCB2YWx1ZURpbSlgLlxuICpcbiAqIFRoZW4sIHRoZSBxdWVyeSBhbmQga2V5IHRlbnNvcnMgYXJlIGRvdC1wcm9kdWN0ZWQgYW5kIHNjYWxlZC4gVGhlc2UgYXJlXG4gKiBzb2Z0bWF4ZWQgdG8gb2J0YWluIGF0dGVudGlvbiBwcm9iYWJpbGl0aWVzLiBUaGUgdmFsdWUgdGVuc29ycyBhcmUgdGhlblxuICogaW50ZXJwb2xhdGVkIGJ5IHRoZXNlIHByb2JhYmlsaXRpZXMsIHRoZW4gY29uY2F0ZW5hdGVkIGJhY2sgdG8gYSBzaW5nbGVcbiAqIHRlbnNvci5cbiAqXG4gKiBGaW5hbGx5LCB0aGUgcmVzdWx0IHRlbnNvciB3aXRoIHRoZSBsYXN0IGRpbWVuc2lvbiBhcyB2YWx1ZURpbSBjYW4gdGFrZSBhblxuICogbGluZWFyIHByb2plY3Rpb24gYW5kIHJldHVybi5cbiAqXG4gKiBXaGVuIHVzaW5nIGBNdWx0aUhlYWRBdHRlbnRpb25gIGluc2lkZSBhIGN1c3RvbSBsYXllciwgdGhlIGN1c3RvbSBsYXllciBtdXN0XG4gKiBpbXBsZW1lbnQgaXRzIG93biBgYnVpbGQoKWAgbWV0aG9kIGFuZCBjYWxsIGBNdWx0aUhlYWRBdHRlbnRpb25gJ3NcbiAqIGBidWlsZEZyb21TaWduYXR1cmUoKWAgdGhlcmUuXG4gKiBUaGlzIGVuYWJsZXMgd2VpZ2h0cyB0byBiZSByZXN0b3JlZCBjb3JyZWN0bHkgd2hlbiB0aGUgbW9kZWwgaXMgbG9hZGVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIFBlcmZvcm1zIDFEIGNyb3NzLWF0dGVudGlvbiBvdmVyIHR3byBzZXF1ZW5jZSBpbnB1dHMgd2l0aCBhbiBhdHRlbnRpb24gbWFzay5cbiAqIFJldHVybnMgdGhlIGFkZGl0aW9uYWwgYXR0ZW50aW9uIHdlaWdodHMgb3ZlciBoZWFkcy5cbiAqXG4gKiBjb25zdCBsYXllciA9IG5ldyBNdWx0aUhlYWRBdHRlbnRpb24oe251bUhlYWRzOiAyLCBrZXlEaW06IDJ9KTtcbiAqIGNvbnN0IHRhcmdldCA9IHRmLmlucHV0KHtzaGFwZTogWzgsIDE2XX0pO1xuICogY29uc3Qgc291cmNlID0gdGYuaW5wdXQoe3NoYXBlOiBbNCwgMTZdfSk7XG4gKiBjb25zdCBvdXRwdXRUZW5zb3IsIHdlaWdodHMgPSBsYXllci5jYWxsQW5kUmV0dXJuQXR0ZW50aW9uU2NvcmVzKFxuICogICAgIHRhcmdldCwge3ZhbHVlOiBzb3VyY2V9KTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dFRlbnNvci5zaGFwZSk7ICAvLyBbbnVsbCwgOCwgMTZdXG4gKiBjb25zb2xlLmxvZyh3ZWlnaHRzLnNoYXBlKTsgIC8vIFtudWxsLCAyLCA4LCA0XVxuICpcbiAqIFBlcmZvcm1zIDJEIHNlbGYtYXR0ZW50aW9uIG92ZXIgYSA1RCBpbnB1dCB0ZW5zb3Igb24gYXhlcyAyIGFuZCAzLlxuICpcbiAqIGNvbnN0IGxheWVyID0gbmV3IE11bHRpSGVhZEF0dGVudGlvbih7XG4gKiAgICBudW1IZWFkczogMiwga2V5RGltOiAyLCBhdHRlbnRpb25BeGVzOiBbMiwgM119KTtcbiAqIGNvbnN0IGlucHV0VGVuc29yID0gdGYuaW5wdXQoe3NoYXBlOiBbNSwgMywgNCwgMTZdfSk7XG4gKiBjb25zdCBvdXRwdXRUZW5zb3IgPSBsYXllci5jYWxsKGlucHV0VGVuc29yLCB7dmFsdWU6IGlucHV0VGVuc29yfSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXRUZW5zb3Iuc2hhcGUpOyAgLy8gW251bGwsIDUsIDMsIDQsIDE2XVxuICpcbiAqIFJldHVybnM6XG4gKiAgICBhdHRlbnRpb25PdXRwdXQ6IFRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uLCBvZiBzaGFwZSBgKEIsIFQsIEUpYCxcbiAqICAgICAgICB3aGVyZSBgVGAgaXMgZm9yIHRhcmdldCBzZXF1ZW5jZSBzaGFwZXMgYW5kIGBFYCBpcyB0aGUgcXVlcnkgaW5wdXRcbiAqICAgICAgICBsYXN0IGRpbWVuc2lvbiBpZiBgb3V0cHV0U2hhcGVgIGlzIGBOb25lYC4gT3RoZXJ3aXNlLCB0aGVcbiAqICAgICAgICBtdWx0aS1oZWFkIG91dHB1dHMgYXJlIHByb2plY3RlZCB0byB0aGUgc2hhcGUgc3BlY2lmaWVkIGJ5XG4gKiAgICAgICAgYG91dHB1dFNoYXBlYC5cbiAqICAgIGF0dGVudGlvblNjb3JlczogbXVsdGktaGVhZCBhdHRlbnRpb24gY29lZmZpY2llbnRzIG92ZXIgYXR0ZW50aW9uIGF4ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aUhlYWRBdHRlbnRpb24gZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ011bHRpSGVhZEF0dGVudGlvbic7XG5cbiAgY29uc3RydWN0b3IoYXJnczogTXVsdGlIZWFkQXR0ZW50aW9uQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICB9XG5cbiAgb3ZlcnJpZGUgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gIH1cblxuICBzdGF0aWMgb3ZlcnJpZGUgZnJvbUNvbmZpZzxUIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGU+KFxuICAgIGNsczogc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGVDb25zdHJ1Y3RvcjxUPixcbiAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFxuICApOiBUIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignTm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgbGF5ZXJzIGFuZCB2YXJpYWJsZXMuXG4gICAqXG4gICAqIE9uY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQsIHRoaXMuYnVpbHRGcm9tU2lnbmF0dXJlIHdpbGwgYmUgc2V0IHRvIHRydWUuXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkRnJvbVNpZ25hdHVyZShxdWVyeTogVGVuc29yLCB2YWx1ZTogVGVuc29yLCBrZXk/OiBUZW5zb3IpIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgIGBOb3QgaW1wbGVtZW50ZWQgeWV0LiBVc2VzICR7YnVpbGRQcm9qZWN0aW9uRXF1YXRpb259LCAke2dldE91dHB1dFNoYXBlfSxcbiAgICAgICAke3RoaXMuZ2V0Q29tbW9uS3dhcmdzRm9yU3VibGF5ZXJ9LCAke3RoaXMuYnVpbGRBdHRlbnRpb259LFxuICAgICAgICR7dGhpcy5tYWtlT3V0cHV0RGVuc2V9LmApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb21tb25Ld2FyZ3NGb3JTdWJsYXllcigpOiBLd2FyZ3Mge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgb3V0cHV0IHByb2plY3Rpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gZnJlZURpbXMgTnVtYmVyIG9mIGZyZWUgZGltZW5zaW9ucyBmb3IgZWluc3VtIGVxdWF0aW9uIGJ1aWxkaW5nLlxuICAgKiBAcGFyYW0gY29tbW9uS3dhcmdzIENvbW1vbiBrZXl3b3JkIGFyZ3VtZW50cyBmb3IgZWluc3VtIGxheWVyLlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGUgcHJvamVjdGlvbiBsYXllci5cbiAgICogQHJldHVybnMgUHJvamVjdGlvbiBsYXllci5cbiAgICovXG4gIHByaXZhdGUgbWFrZU91dHB1dERlbnNlKFxuICAgIGZyZWVEaW1zOiBudW1iZXIsIGNvbW1vbkt3YXJnczogS3dhcmdzLCBuYW1lPzogc3RyaW5nXG4gICk6IEt3YXJncyB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG11bHRpLWhlYWQgZG90LXByb2R1Y3QgYXR0ZW50aW9uIGNvbXB1dGF0aW9ucy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBidWlsZHMgYXR0cmlidXRlcyBuZWNlc3NhcnkgZm9yIGBfY29tcHV0ZV9hdHRlbnRpb25gIHRvXG4gICAqIGN1c3RvbWl6ZSBhdHRlbnRpb24gY29tcHV0YXRpb24gdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBkb3QtcHJvZHVjdFxuICAgKiBhdHRlbnRpb24uXG4gICAqXG4gICAqIEBwYXJhbSByYW5rIFRoZSByYW5rIG9mIHF1ZXJ5LCBrZXksIHZhbHVlIHRlbnNvcnMuXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkQXR0ZW50aW9uKHJhbms6IG51bWJlcikge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vdCBpbXBsZW1lbnRlZCB5ZXQuIFVzZXMgJHtidWlsZEF0dGVudGlvbkVxdWF0aW9ufS5gKTtcbiAgfVxuXG4gIHByaXZhdGUgbWFza2VkU29mdG1heChcbiAgICBhdHRlbnRpb25TY29yZXM6IFRlbnNvciwgYXR0ZW50aW9uTWFzaz86IFRlbnNvclxuICApOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgRG90LXByb2R1Y3QgYXR0ZW50aW9uIHdpdGggcXVlcnksIGtleSwgdmFsdWUgdGVuc29ycy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBkZWZpbmVzIHRoZSBjb21wdXRhdGlvbiBpbnNpZGUgYGNhbGxgIHdpdGggcHJvamVjdGVkXG4gICAqIG11bHRpLWhlYWQgUSwgSywgViBpbnB1dHMuIFVzZXJzIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGZvclxuICAgKiBjdXN0b21pemVkIGF0dGVudGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IFByb2plY3RlZCBxdWVyeSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFQsIE4sIGtleV9kaW0pYC5cbiAgICogQHBhcmFtIGtleSAgUHJvamVjdGVkIGtleSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFMsIE4sIGtleV9kaW0pYC5cbiAgICogQHBhcmFtIHZhbHVlIFByb2plY3RlZCB2YWx1ZSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFMsIE4sIHZhbHVlX2RpbSlgLlxuICAgKiBAcGFyYW0gYXR0ZW50aW9uTWFzayBBIGJvb2xlYW4gbWFzayBvZiBzaGFwZSBgKEIsIFQsIFMpYCwgdGhhdCBwcmV2ZW50c1xuICAgKiAgICBhdHRlbnRpb24gdG8gY2VydGFpbiBwb3NpdGlvbnMuIEl0IGlzIGdlbmVyYWxseSBub3QgbmVlZGVkIGlmXG4gICAqICAgIHRoZSBgcXVlcnlgIGFuZCBgdmFsdWVgIChhbmQvb3IgYGtleWApIGFyZSBtYXNrZWQuXG4gICAqIEBwYXJhbSB0cmFpbmluZyBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgbGF5ZXIgc2hvdWxkIGJlaGF2ZVxuICAgKiAgICBpbiB0cmFpbmluZyBtb2RlIChhZGRpbmcgZHJvcG91dCkgb3IgaW4gaW5mZXJlbmNlIG1vZGUgKGRvaW5nXG4gICAqICAgIG5vdGhpbmcpLlxuICAgKiBAcmV0dXJucyBhdHRlbnRpb25PdXRwdXQ6IE11bHRpLWhlYWRlZCBvdXRwdXRzIG9mIGF0dGVudGlvbiBjb21wdXRhdGlvbi5cbiAgICogQHJldHVybnMgYXR0ZW50aW9uU2NvcmVzOiBNdWx0aS1oZWFkZWQgYXR0ZW50aW9uIHdlaWdodHMuXG4gICAqL1xuICBwcml2YXRlIGNvbXB1dGVBdHRlbnRpb24oXG4gICAgcXVlcnk6IFRlbnNvcixcbiAgICBrZXk6IFRlbnNvcixcbiAgICB2YWx1ZTogVGVuc29yLFxuICAgIGF0dGVudGlvbk1hc2s/OiBUZW5zb3IsXG4gICAgdHJhaW5pbmc/OiBib29sZWFuXG4gICk6IFtUZW5zb3IsIFRlbnNvcl0ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vdCBpbXBsZW1lbnRlZCB5ZXQuIFVzZXMgJHt0aGlzLm1hc2tlZFNvZnRtYXh9LmApO1xuICB9XG5cbiAgb3ZlcnJpZGUgY2FsbChcbiAgICBxdWVyeTogVGVuc29yLCBrd2FyZ3M6IE11bHRpSGVhZEF0dGVudGlvbk9wdGlvbnNcbiAgKTogVGVuc29yfFRlbnNvcjJEIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsQW5kUmV0dXJuQXR0ZW50aW9uU2NvcmVzKHF1ZXJ5LCBrd2FyZ3MpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4YWN0bHkgbGlrZSBgY2FsbGAgZXhjZXB0IGFsc28gcmV0dXJucyB0aGUgYXR0ZW50aW9uIHNjb3Jlcy5cbiAgICovXG4gIGNhbGxBbmRSZXR1cm5BdHRlbnRpb25TY29yZXMoXG4gICAgcXVlcnk6IFRlbnNvciwga3dhcmdzOiBNdWx0aUhlYWRBdHRlbnRpb25PcHRpb25zXG4gICk6IFtUZW5zb3IxRHxUZW5zb3IyRCwgVGVuc29yMUR8VGVuc29yMkRdIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgIGBOb3QgaW1wbGVtZW50ZWQgeWV0LiBVc2VzICR7dGhpcy5idWlsZEZyb21TaWduYXR1cmV9LFxuICAgICAgICR7dGhpcy5jb21wdXRlQXR0ZW50aW9uTWFza30sICR7dGhpcy5jb21wdXRlQXR0ZW50aW9ufS5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgYXR0ZW50aW9uIG1hc2suXG4gICAqXG4gICAqICogVGhlIGBxdWVyeWAncyBtYXNrIGlzIHJlc2hhcGVkIGZyb20gW0IsIFRdIHRvIFtCLCBULCAxXS5cbiAgICogKiBUaGUgYHZhbHVlYCdzIG1hc2sgaXMgcmVzaGFwZWQgZnJvbSBbQiwgU10gdG8gW0IsIDEsIFNdLlxuICAgKiAqIFRoZSBga2V5YCdzIG1hc2sgaXMgcmVzaGFwZWQgZnJvbSBbQiwgU10gdG8gW0IsIDEsIFNdLiBUaGUgYGtleWAnc1xuICAgKiAgIG1hc2sgaXMgaWdub3JlZCBpZiBga2V5YCBpcyBgTm9uZWAgb3IgaWYgYGtleSBpcyB2YWx1ZWAuXG4gICAqICogSWYgYHVzZUNhdXNhbE1hc2s9dHJ1ZWAsIHRoZW4gdGhlIGNhdXNhbCBtYXNrIGlzIGNvbXB1dGVkLiBJdHMgc2hhcGVcbiAgICogICBpcyBbMSwgVCwgU10uXG4gICAqXG4gICAqIEFsbCBkZWZpbmVkIG1hc2tzIGFyZSBtZXJnZWQgdXNpbmcgYSBsb2dpY2FsIEFORCBvcGVyYXRpb24gKGAmYCkuXG4gICAqXG4gICAqIEluIGdlbmVyYWwsIGlmIHRoZSBgcXVlcnlgIGFuZCBgdmFsdWVgIGFyZSBtYXNrZWQsIHRoZW4gdGhlcmUgaXMgbm8gbmVlZFxuICAgKiB0byBkZWZpbmUgdGhlIGBhdHRlbnRpb25NYXNrYC5cbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IFByb2plY3RlZCBxdWVyeSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFQsIE4sIGtleV9kaW0pYC5cbiAgICogQHBhcmFtIGtleSAgUHJvamVjdGVkIGtleSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFMsIE4sIGtleV9kaW0pYC5cbiAgICogQHBhcmFtIHZhbHVlIFByb2plY3RlZCB2YWx1ZSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFMsIE4sIHZhbHVlX2RpbSlgLlxuICAgKiBAcGFyYW0gYXR0ZW50aW9uTWFzayBBIGJvb2xlYW4gbWFzayBvZiBzaGFwZSBgKEIsIFQsIFMpYCwgdGhhdCBwcmV2ZW50c1xuICAgKiAgICBhdHRlbnRpb24gdG8gY2VydGFpbiBwb3NpdGlvbnMuXG4gICAqIEBwYXJhbSB1c2VDYXVzYWxNYXNrICBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0byBhcHBseSBhIGNhdXNhbFxuICAgKiAgICBtYXNrIHRvIHByZXZlbnQgdG9rZW5zIGZyb20gYXR0ZW5kaW5nIHRvIGZ1dHVyZSB0b2tlbnMgKGUuZy4sXG4gICAqICAgIHVzZWQgaW4gYSBkZWNvZGVyIFRyYW5zZm9ybWVyKS5cbiAgICogQHJldHVybnMgYXR0ZW50aW9uTWFzazogQSBib29sZWFuIG1hc2sgb2Ygc2hhcGUgYChCLCBULCBTKWAsIHRoYXQgcHJldmVudHNcbiAgICogICAgYXR0ZW50aW9uIHRvIGNlcnRhaW4gcG9zaXRpb25zLCBiYXNlZCBvbiB0aGUgS2VyYXMgbWFza3Mgb2YgdGhlXG4gICAqICAgIGBxdWVyeWAsIGBrZXlgLCBgdmFsdWVgLCBhbmQgYGF0dGVudGlvbk1hc2tgIHRlbnNvcnMsIGFuZCB0aGVcbiAgICogICAgY2F1c2FsIG1hc2sgaWYgYHVzZUNhdXNhbE1hc2s9dHJ1ZWAuXG4gICAqL1xuICBwcml2YXRlIGNvbXB1dGVBdHRlbnRpb25NYXNrKFxuICAgIHF1ZXJ5OiBUZW5zb3IsXG4gICAgdmFsdWU6IFRlbnNvcixcbiAgICBrZXk/OiBUZW5zb3IsXG4gICAgYXR0ZW50aW9uTWFzaz86IFRlbnNvcixcbiAgICB1c2VDYXVzYWxNYXNrPzogYm9vbGVhblxuICApOiBUZW5zb3Ige1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vdCBpbXBsZW1lbnRlZCB5ZXQuIFVzZXMgJHt0aGlzLmNvbXB1dGVDYXN1YWxNYXNrfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgY2F1c2FsIG1hc2sgKGUuZy4sIGZvciBtYXNrZWQgc2VsZi1hdHRlbnRpb24gbGF5ZXJzKS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGlmIHF1ZXJ5IGFuZCB2YWx1ZSBib3RoIGNvbnRhaW4gc2VxdWVuY2VzIG9mIGxlbmd0aCA0LFxuICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBib29sZWFuIGBUZW5zb3JgIGVxdWFsIHRvOlxuICAgKlxuICAgKiBgYGBcbiAgICogW1tbdHJ1ZSwgIGZhbHNlLCBmYWxzZSwgZmFsc2VdLFxuICAgKiAgIFt0cnVlLCAgdHJ1ZSwgIGZhbHNlLCBmYWxzZV0sXG4gICAqICAgW3RydWUsICB0cnVlLCAgdHJ1ZSwgIGZhbHNlXSxcbiAgICogICBbdHJ1ZSwgIHRydWUsICB0cnVlLCAgdHJ1ZV1dXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHF1ZXJ5IHF1ZXJ5IGBUZW5zb3JgIG9mIHNoYXBlIGAoQiwgVCwgLi4uKWAuXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBgVGVuc29yYCBvZiBzaGFwZSBgKEIsIFMsIC4uLilgIChkZWZhdWx0cyB0byBxdWVyeSkuXG4gICAqIEByZXR1cm5zIG1hc2s6IEEgYm9vbGVhbiBgVGVuc29yYCBvZiBzaGFwZSBbMSwgVCwgU10gY29udGFpbmluZyBhIGxvd2VyXG4gICAqICAgIHRyaWFuZ3VsYXIgbWF0cml4IG9mIHNoYXBlIFtULCBTXS5cbiAgICovXG4gIHByaXZhdGUgY29tcHV0ZUNhc3VhbE1hc2socXVlcnk6IFRlbnNvciwgdmFsdWU/OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlcyBBIGxpc3Qgb2YgW3F1ZXJ5U2hhcGUsIHZhbHVlU2hhcGVdIG9yXG4gICAqICAgIFtxdWVyeVNoYXBlLCB2YWx1ZVNoYXBlLCBrZXlTaGFwZV0uIElmIG5vIGtleVNoYXBlIHByb3ZpZGVkLCB2YWx1ZVNoYXBlXG4gICAqICAgIGlzIGFzc3VtZWQgYXMgdGhlIGtleVNoYXBlLlxuICAgKi9cbiAgb3ZlcnJpZGUgY29tcHV0ZU91dHB1dFNoYXBlKFxuICAgIGlucHV0U2hhcGVzOiBbU2hhcGUsIFNoYXBlXSB8IFtTaGFwZSwgU2hhcGUsIFNoYXBlXVxuICApOiBTaGFwZSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNdWx0aUhlYWRBdHRlbnRpb24pO1xuIl19