/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 *  Transformer decoder block implementation based on TFJS `Layer`.
 */
/* Original source: keras_nlp/layers/modeling/transformer_decoder.py */
import { serialization } from '@tensorflow/tfjs-core';
import { Layer, } from '../../../engine/topology';
import { NotImplementedError } from '../../../errors';
/**
 * Transformer decoder.
 *
 * This class follows the architecture of the transformer decoder layer in the
 * paper [Attention is All You Need](https://arxiv.org/abs/1706.03762). Users
 * can instantiate multiple instances of this class to stack up a decoder.
 *
 * By default, this layer will apply a causal mask to the decoder attention
 * layer. This layer will correctly compute an attention mask from an implicit
 * padding mask (for example, by passing `maskZero=true` to a
 * `tf.layers.embedding` layer). See the Masking and Padding
 * [guide](https://keras.io/guides/understanding_masking_and_padding/)
 * for more details.
 *
 * This layer can be called with either one or two inputs. The number of inputs
 * must be consistent across all calls. The options are as follows:
 *    `layer.call(decoderSequence)`: no cross-attention will be built into the
 *         decoder block. This is useful when building a "decoder-only"
 *         transformer such as GPT-2.
 *    `layer.call(decoderSequence, {encoderSequence})`: cross-attention will be
 *         built into the decoder block. This is useful when building an
 *         "encoder-decoder" transformer, such as the original transformer
 *         model described in Attention is All You Need.
 *
 * Examples:
 * ```js
 * // Create a single transformer decoder layer.
 * const decoder = new TransformerDecoder({intermediateDim: 64, numHeads: 8});
 *
 * // Create a simple model containing the decoder.
 * const decoderInput = tf.input({shape: [10, 64]});
 * const encoderInput = tf.input({shape: {[10, 64]});
 * const output = decoder.call(decoderInput, {encoderInput});
 * const model = tf.model({
 *     inputs: [decoderInput, encoderInput],
 *     outputs: output,
 * );
 *
 * // Call decoder on the inputs.
 * const decoderInputData = tf.randomUniform([2, 10, 64]);
 * const encoderInputData = tf.randomUniform([2, 10, 64]);
 * const decoderOutput = model.predict([decoderInputData, encoderInputData]);
 * ```
 *
 * References:
 *  - [Vaswani et al., 2017](https://arxiv.org/abs/1706.03762)
 */
class TransformerDecoder extends Layer {
    constructor(args) {
        super(args);
        throw new NotImplementedError(`Not implemented yet.`);
    }
    /**
     *
     * @param inputShape decoderSequenceShape or
     *  [decoderSequenceShape, encoderSequenceShape]
     */
    build(inputShape) {
        throw new NotImplementedError(`Not implemented yet.`);
    }
    apply(inputs, kwargs) {
        throw new NotImplementedError(`Not implemented yet.`);
    }
    call(decoderSequence, kwargs) {
        return this.callAndReturnCaches(decoderSequence, kwargs)[0];
    }
    /**
     * @returns One of three things, depending on call arguments:
     *   - `[outputs, null, null]`, if `selfAttentionCache` is `null`.
     *   - `[outputs, selfAttentionCache, null]`, if `selfAttentionCache` is
     *     set and the layer has no cross-attention.
     *   - `[outputs, selfAttentionCache, crossAttentionCache]`, if
     *     `selfAttentionCache` and `crossAttentionCache` are set and
     *     the layer has cross-attention.
     */
    callAndReturnCaches(decoderSequence, kwargs) {
        throw new NotImplementedError(`Not implemented yet. Uses ${this.computeSelfAttentionMask}`);
    }
    computeSelfAttentionMask(decoderSequence, decoderPaddingMask, decoderAttentionMask, useCasualMask, selfAttentionCache, selfAttentionCacheUpdateIndex) {
        throw new NotImplementedError(`Not implemented yet.`);
    }
    getConfig() {
        throw new NotImplementedError(`Not implemented yet.`);
    }
    computeOutputShape(decoderSequenceShape) {
        throw new NotImplementedError(`Not implemented yet.`);
    }
}
/** @nocollapse */
TransformerDecoder.className = 'TransformerDecoder';
export { TransformerDecoder };
serialization.registerClass(TransformerDecoder);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtZXJfZGVjb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvbmxwL21vZGVsaW5nL3RyYW5zZm9ybWVyX2RlY29kZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUg7O0dBRUc7QUFFSCx1RUFBdUU7QUFDdkUsT0FBTyxFQUE4QixhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVsRixPQUFPLEVBQUUsS0FBSyxHQUFjLE1BQU0sMEJBQTBCLENBQUM7QUFDN0QsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUErSHREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOENHO0FBQ0gsTUFBYSxrQkFBbUIsU0FBUSxLQUFLO0lBSTNDLFlBQVksSUFBNEI7UUFDdEMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osTUFBTSxJQUFJLG1CQUFtQixDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDTSxLQUFLLENBQUMsVUFBZ0M7UUFDN0MsTUFBTSxJQUFJLG1CQUFtQixDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVRLEtBQUssQ0FDWixNQUF1QixFQUFFLE1BQWtDO1FBRTNELE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFUSxJQUFJLENBQ1gsZUFBdUIsRUFBRSxNQUFpQztRQUUxRCxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsbUJBQW1CLENBQ2pCLGVBQXVCLEVBQUUsTUFBaUM7UUFFMUQsTUFBTSxJQUFJLG1CQUFtQixDQUMzQiw2QkFBNkIsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRU8sd0JBQXdCLENBQzlCLGVBQXVCLEVBQ3ZCLGtCQUEwQixFQUMxQixvQkFBNEIsRUFDNUIsYUFBc0IsRUFDdEIsa0JBQTBCLEVBQzFCLDZCQUE0QztRQUU1QyxNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRVEsU0FBUztRQUNoQixNQUFNLElBQUksbUJBQW1CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRVEsa0JBQWtCLENBQUMsb0JBQTJCO1FBQ3JELE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7O0FBOURELGtCQUFrQjtBQUNGLDRCQUFTLEdBQUcsb0JBQW9CLENBQUM7U0FGdEMsa0JBQWtCO0FBaUUvQixhQUFhLENBQUMsYUFBYSxDQUFDLGtCQUFrQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogIFRyYW5zZm9ybWVyIGRlY29kZXIgYmxvY2sgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gVEZKUyBgTGF5ZXJgLlxuICovXG5cbi8qIE9yaWdpbmFsIHNvdXJjZToga2VyYXNfbmxwL2xheWVycy9tb2RlbGluZy90cmFuc2Zvcm1lcl9kZWNvZGVyLnB5ICovXG5pbXBvcnQgeyBUZW5zb3IsIFRlbnNvcjFELCBUZW5zb3IyRCwgc2VyaWFsaXphdGlvbiB9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7IExheWVyLCBMYXllckFyZ3MsIH0gZnJvbSAnLi4vLi4vLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7IE5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgSW5pdGlhbGl6ZXJJZGVudGlmaWVyIH0gZnJvbSAnLi4vLi4vLi4vaW5pdGlhbGl6ZXJzJztcbmltcG9ydCB7IEFjdGl2YXRpb25JZGVudGlmaWVyIH0gZnJvbSAnLi4vLi4vLi4va2VyYXNfZm9ybWF0L2FjdGl2YXRpb25fY29uZmlnJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vLi4vLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBUcmFuc2Zvcm1lckRlY29kZXJBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIEludGVnZXIuIFRoZSBoaWRkZW4gc2l6ZSBvZiBmZWVkZm9yd2FyZCBuZXR3b3JrLlxuICAgKi9cbiAgaW50ZXJtZWRpYXRlRGltOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEludGVnZXIuIFRoZSBudW1iZXIgb2YgaGVhZHMgaW4gTXVsdGlIZWFkQXR0ZW50aW9uLlxuICAgKi9cbiAgbnVtSGVhZHM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGRyb3BvdXQgdmFsdWUsIHNoYXJlZCBieSBNdWx0aUhlYWRBdHRlbnRpb24gYW5kIGZlZWRmb3J3YXJkIG5ldHdvcmsuXG4gICAqIERlZmF1bHRzIHRvIGAwLmAuXG4gICAqL1xuICBkcm9wb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgYWN0aXZhdGlvbiBmdW5jdGlvbiBvZiBmZWVkZm9yd2FyZCBuZXR3b3JrLlxuICAgKiBEZWZhdWx0cyB0byBgXCJyZWx1XCJgLlxuICAgKi9cbiAgYWN0aXZhdGlvbj86IEFjdGl2YXRpb25JZGVudGlmaWVyO1xuXG4gIC8qKlxuICAgKiBUaGUgZXBzIHZhbHVlIGluIGxheWVyIG5vcm1hbGl6YXRpb24gY29tcG9uZW50cy5cbiAgICogRGVmYXVsdHMgdG8gYDFlLTVgLlxuICAgKi9cbiAgbGF5ZXJOb3JtRXBzaWxvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGtlcm5lbCBpbml0aWFsaXplciBmb3IgdGhlIGRlbnNlIGFuZCBtdWx0aWhlYWRlZCBhdHRlbnRpb24gbGF5ZXJzLlxuICAgKiBEZWZhdWx0cyB0byBgXCJnbG9yb3RVbmlmb3JtXCJgLlxuICAgKi9cbiAga2VybmVsSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBiaWFzIGluaXRpYWxpemVyIGZvciB0aGUgZGVuc2UgYW5kIG11bHRpaGVhZGVkIGF0dGVudGlvbiBsYXllcnMuXG4gICAqIERlZmF1bHRzIHRvIGBcInplcm9zXCJgLlxuICAgKi9cbiAgYmlhc0luaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGUgaW5wdXRzIHRvIHRoZSBhdHRlbnRpb24gbGF5ZXIocykgYW5kIHRoZSBpbnRlcm1lZGlhdGUgZGVuc2VcbiAgICogbGF5ZXIgYXJlIG5vcm1hbGl6ZWQgKHNpbWlsYXIgdG8gR1BULTIpLiBJZiBzZXQgdG8gZmFsc2UsIG91dHB1dHMgb2ZcbiAgICogYXR0ZW50aW9uIGxheWVyIGFuZCBpbnRlcm1lZGlhdGUgZGVuc2UgbGF5ZXIgYXJlIG5vcm1hbGl6ZWRcbiAgICogKHNpbWlsYXIgdG8gQkVSVCkuXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBub3JtYWxpemVGaXJzdDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFRyYW5zZm9ybWVyRGVjb2Rlck9wdGlvbnMge1xuICAvKipcbiAgICogZGVjb2RlclNlcXVlbmNlOiBUaGUgZGVjb2RlIGlucHV0IHNlcXVlbmNlLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGVuY29kZXIgaW5wdXQgc2VxdWVuY2UuIEZvciBkZWNvZGVyIG9ubHkgbW9kZWxzIChsaWtlIEdQVDIpLCB0aGlzXG4gICAqIHNob3VsZCBiZSBsZWZ0IGBudWxsYC4gT25jZSB0aGUgbW9kZWwgaXMgY2FsbGVkIHdpdGhvdXQgYW4gZW5jb2RlclNlcXVlbmNlLFxuICAgKiB5b3UgY2Fubm90IGNhbGwgaXQgYWdhaW4gd2l0aCBlbmNvZGVyU2VxdWVuY2UuXG4gICAqL1xuICBlbmNvZGVyU2VxdWVuY2U/OiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBUZW5zb3IsIHRoZSBwYWRkaW5nIG1hc2sgb2YgZGVjb2RlciBzZXF1ZW5jZSwgbXVzdCBiZSBvZiBzaGFwZVxuICAgKiBgW2JhdGNoU2l6ZSwgZGVjb2RlclNlcXVlbmNlTGVuZ3RoXWAuXG4gICAqL1xuICBkZWNvZGVyUGFkZGluZ01hc2s6IFRlbnNvcjtcblxuICAvKipcbiAgICogQSBib29sZWFuIFRlbnNvci4gQ3VzdG9taXplZCBkZWNvZGVyIHNlcXVlbmNlIG1hc2ssIG11c3QgYmUgb2Ygc2hhcGVcbiAgICogYFtiYXRjaFNpemUsIGRlY29kZXJTZXF1ZW5jZUxlbmd0aCwgZGVjb2RlclNlcXVlbmNlTGVuZ3RoXWAuXG4gICAqL1xuICBkZWNvZGVyQXR0ZW50aW9uTWFzaz86IFRlbnNvcjtcblxuICAvKipcbiAgICogQSBib29sZWFuIFRlbnNvciwgdGhlIHBhZGRpbmcgbWFzayBvZiBlbmNvZGVyIHNlcXVlbmNlLCBtdXN0IGJlIG9mIHNoYXBlXG4gICAqIGBbYmF0Y2hTaXplLCBlbmNvZGVyU2VxdWVuY2VMZW5ndGhdYC5cbiAgICovXG4gIGVuY29kZXJQYWRkaW5nTWFzaz86IFRlbnNvcjtcblxuICAvKipcbiAgICogQSBib29sZWFuIFRlbnNvci4gQ3VzdG9taXplZCBlbmNvZGVyIHNlcXVlbmNlIG1hc2ssIG11c3QgYmUgb2Ygc2hhcGVcbiAgICogYFtiYXRjaFNpemUsIGVuY29kZXJTZXF1ZW5jZUxlbmd0aCwgZW5jb2RlclNlcXVlbmNlTGVuZ3RoXWAuXG4gICAqL1xuICBlbmNvZGVyQXR0ZW50aW9uTWFzaz86IFRlbnNvcjtcblxuICAvKipcbiAgICogQSBkZW5zZSBmbG9hdCBUZW5zb3IuIFRoZSBjYWNoZSBvZiBrZXkvdmFsdWVzIHBhaXJzIGluIHRoZSBzZWxmLWF0dGVudGlvblxuICAgKiBsYXllci4gSGFzIHNoYXBlIGBbYmF0Y2hTaXplLCAyLCBtYXhTZXFMZW4sIG51bUhlYWRzLCBrZXlEaW1zXWAuXG4gICAqL1xuICBzZWxmQXR0ZW50aW9uQ2FjaGU/OiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIEludGVnZXIgb3IgSW50ZWdlciBUZW5zb3IuIFRoZSBpbmRleCBhdCB3aGljaCB0byB1cGRhdGUgdGhlXG4gICAqIGBzZWxmQXR0ZW50aW9uQ2FjaGVgLiBVc3VhbGx5LCB0aGlzIGlzIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB0b2tlblxuICAgKiBiZWluZyBwcm9jZXNzZWQgZHVyaW5nIGRlY29kaW5nLlxuICAgKi9cbiAgc2VsZkF0dGVudGlvbkNhY2hlVXBkYXRlSW5kZXg/OiBudW1iZXJ8VGVuc29yO1xuXG4gIC8qKlxuICAgKiBBIGRlbnNlIGZsb2F0IFRlbnNvci4gVGhlIGNhY2hlIG9mIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgY3Jvc3MtYXR0ZW50aW9uXG4gICAqIGxheWVyLiBIYXMgc2hhcGUgYFtiYXRjaFNpemUsIDIsIFMsIG51bUhlYWRzLCBrZXlEaW1zXWAuXG4gICAqL1xuICBjcm9zc0F0dGVudGlvbkNhY2hlPzogVGVuc29yO1xuXG4gIC8qKlxuICAgKiBJbnRlZ2VyIG9yIEludGVnZXIgVGVuc29yLiBUaGUgaW5kZXggYXQgd2hpY2ggdG8gdXBkYXRlIHRoZVxuICAgKiBgY3Jvc3NBdHRlbnRpb25DYWNoZWAuIFVzdWFsbHksIHRoaXMgaXMgZWl0aGVyIGAwYCAoY29tcHV0ZSB0aGUgZW50aXJlXG4gICAqIGBjcm9zc0F0dGVudGlvbkNhY2hlYCksIG9yIGBudWxsYCAocmV1c2UgYSBwcmV2aW91c2x5IGNvbXB1dGVkXG4gICAqIGBjcm9zc0F0dGVudGlvbkNhY2hlYCkuXG4gICAqL1xuICBjcm9zc0F0dGVudGlvbkNhY2hlVXBkYXRlSW5kZXg/OiBudW1iZXJ8VGVuc29yO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBhIGNhdXNhbCBtYXNrIChtYXNraW5nIG91dCBmdXR1cmUgaW5wdXQpIGlzIGFwcGxpZWQgb24gdGhlIGRlY29kZXJcbiAgICogc2VxdWVuY2UuXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIHVzZUNhdXNhbE1hc2s/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybWVyIGRlY29kZXIuXG4gKlxuICogVGhpcyBjbGFzcyBmb2xsb3dzIHRoZSBhcmNoaXRlY3R1cmUgb2YgdGhlIHRyYW5zZm9ybWVyIGRlY29kZXIgbGF5ZXIgaW4gdGhlXG4gKiBwYXBlciBbQXR0ZW50aW9uIGlzIEFsbCBZb3UgTmVlZF0oaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDM3NjIpLiBVc2Vyc1xuICogY2FuIGluc3RhbnRpYXRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHRvIHN0YWNrIHVwIGEgZGVjb2Rlci5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGxheWVyIHdpbGwgYXBwbHkgYSBjYXVzYWwgbWFzayB0byB0aGUgZGVjb2RlciBhdHRlbnRpb25cbiAqIGxheWVyLiBUaGlzIGxheWVyIHdpbGwgY29ycmVjdGx5IGNvbXB1dGUgYW4gYXR0ZW50aW9uIG1hc2sgZnJvbSBhbiBpbXBsaWNpdFxuICogcGFkZGluZyBtYXNrIChmb3IgZXhhbXBsZSwgYnkgcGFzc2luZyBgbWFza1plcm89dHJ1ZWAgdG8gYVxuICogYHRmLmxheWVycy5lbWJlZGRpbmdgIGxheWVyKS4gU2VlIHRoZSBNYXNraW5nIGFuZCBQYWRkaW5nXG4gKiBbZ3VpZGVdKGh0dHBzOi8va2VyYXMuaW8vZ3VpZGVzL3VuZGVyc3RhbmRpbmdfbWFza2luZ19hbmRfcGFkZGluZy8pXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFRoaXMgbGF5ZXIgY2FuIGJlIGNhbGxlZCB3aXRoIGVpdGhlciBvbmUgb3IgdHdvIGlucHV0cy4gVGhlIG51bWJlciBvZiBpbnB1dHNcbiAqIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgYWxsIGNhbGxzLiBUaGUgb3B0aW9ucyBhcmUgYXMgZm9sbG93czpcbiAqICAgIGBsYXllci5jYWxsKGRlY29kZXJTZXF1ZW5jZSlgOiBubyBjcm9zcy1hdHRlbnRpb24gd2lsbCBiZSBidWlsdCBpbnRvIHRoZVxuICogICAgICAgICBkZWNvZGVyIGJsb2NrLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIGEgXCJkZWNvZGVyLW9ubHlcIlxuICogICAgICAgICB0cmFuc2Zvcm1lciBzdWNoIGFzIEdQVC0yLlxuICogICAgYGxheWVyLmNhbGwoZGVjb2RlclNlcXVlbmNlLCB7ZW5jb2RlclNlcXVlbmNlfSlgOiBjcm9zcy1hdHRlbnRpb24gd2lsbCBiZVxuICogICAgICAgICBidWlsdCBpbnRvIHRoZSBkZWNvZGVyIGJsb2NrLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIGFuXG4gKiAgICAgICAgIFwiZW5jb2Rlci1kZWNvZGVyXCIgdHJhbnNmb3JtZXIsIHN1Y2ggYXMgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybWVyXG4gKiAgICAgICAgIG1vZGVsIGRlc2NyaWJlZCBpbiBBdHRlbnRpb24gaXMgQWxsIFlvdSBOZWVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICogYGBganNcbiAqIC8vIENyZWF0ZSBhIHNpbmdsZSB0cmFuc2Zvcm1lciBkZWNvZGVyIGxheWVyLlxuICogY29uc3QgZGVjb2RlciA9IG5ldyBUcmFuc2Zvcm1lckRlY29kZXIoe2ludGVybWVkaWF0ZURpbTogNjQsIG51bUhlYWRzOiA4fSk7XG4gKlxuICogLy8gQ3JlYXRlIGEgc2ltcGxlIG1vZGVsIGNvbnRhaW5pbmcgdGhlIGRlY29kZXIuXG4gKiBjb25zdCBkZWNvZGVySW5wdXQgPSB0Zi5pbnB1dCh7c2hhcGU6IFsxMCwgNjRdfSk7XG4gKiBjb25zdCBlbmNvZGVySW5wdXQgPSB0Zi5pbnB1dCh7c2hhcGU6IHtbMTAsIDY0XX0pO1xuICogY29uc3Qgb3V0cHV0ID0gZGVjb2Rlci5jYWxsKGRlY29kZXJJbnB1dCwge2VuY29kZXJJbnB1dH0pO1xuICogY29uc3QgbW9kZWwgPSB0Zi5tb2RlbCh7XG4gKiAgICAgaW5wdXRzOiBbZGVjb2RlcklucHV0LCBlbmNvZGVySW5wdXRdLFxuICogICAgIG91dHB1dHM6IG91dHB1dCxcbiAqICk7XG4gKlxuICogLy8gQ2FsbCBkZWNvZGVyIG9uIHRoZSBpbnB1dHMuXG4gKiBjb25zdCBkZWNvZGVySW5wdXREYXRhID0gdGYucmFuZG9tVW5pZm9ybShbMiwgMTAsIDY0XSk7XG4gKiBjb25zdCBlbmNvZGVySW5wdXREYXRhID0gdGYucmFuZG9tVW5pZm9ybShbMiwgMTAsIDY0XSk7XG4gKiBjb25zdCBkZWNvZGVyT3V0cHV0ID0gbW9kZWwucHJlZGljdChbZGVjb2RlcklucHV0RGF0YSwgZW5jb2RlcklucHV0RGF0YV0pO1xuICogYGBgXG4gKlxuICogUmVmZXJlbmNlczpcbiAqICAtIFtWYXN3YW5pIGV0IGFsLiwgMjAxN10oaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDM3NjIpXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1lckRlY29kZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ1RyYW5zZm9ybWVyRGVjb2Rlcic7XG5cbiAgY29uc3RydWN0b3IoYXJnczogVHJhbnNmb3JtZXJEZWNvZGVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgeWV0LmApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIGRlY29kZXJTZXF1ZW5jZVNoYXBlIG9yXG4gICAqICBbZGVjb2RlclNlcXVlbmNlU2hhcGUsIGVuY29kZXJTZXF1ZW5jZVNoYXBlXVxuICAgKi9cbiAgb3ZlcnJpZGUgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8W1NoYXBlLCBTaGFwZV0pOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihgTm90IGltcGxlbWVudGVkIHlldC5gKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGFwcGx5KFxuICAgIGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M/OiBUcmFuc2Zvcm1lckRlY29kZXJPcHRpb25zXG4gICk6IFRlbnNvciB8IFRlbnNvcltdIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihgTm90IGltcGxlbWVudGVkIHlldC5gKTtcbiAgfVxuXG4gIG92ZXJyaWRlIGNhbGwoXG4gICAgZGVjb2RlclNlcXVlbmNlOiBUZW5zb3IsIGt3YXJnczogVHJhbnNmb3JtZXJEZWNvZGVyT3B0aW9uc1xuICApOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aGlzLmNhbGxBbmRSZXR1cm5DYWNoZXMoZGVjb2RlclNlcXVlbmNlLCBrd2FyZ3MpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIE9uZSBvZiB0aHJlZSB0aGluZ3MsIGRlcGVuZGluZyBvbiBjYWxsIGFyZ3VtZW50czpcbiAgICogICAtIGBbb3V0cHV0cywgbnVsbCwgbnVsbF1gLCBpZiBgc2VsZkF0dGVudGlvbkNhY2hlYCBpcyBgbnVsbGAuXG4gICAqICAgLSBgW291dHB1dHMsIHNlbGZBdHRlbnRpb25DYWNoZSwgbnVsbF1gLCBpZiBgc2VsZkF0dGVudGlvbkNhY2hlYCBpc1xuICAgKiAgICAgc2V0IGFuZCB0aGUgbGF5ZXIgaGFzIG5vIGNyb3NzLWF0dGVudGlvbi5cbiAgICogICAtIGBbb3V0cHV0cywgc2VsZkF0dGVudGlvbkNhY2hlLCBjcm9zc0F0dGVudGlvbkNhY2hlXWAsIGlmXG4gICAqICAgICBgc2VsZkF0dGVudGlvbkNhY2hlYCBhbmQgYGNyb3NzQXR0ZW50aW9uQ2FjaGVgIGFyZSBzZXQgYW5kXG4gICAqICAgICB0aGUgbGF5ZXIgaGFzIGNyb3NzLWF0dGVudGlvbi5cbiAgICovXG4gIGNhbGxBbmRSZXR1cm5DYWNoZXMoXG4gICAgZGVjb2RlclNlcXVlbmNlOiBUZW5zb3IsIGt3YXJnczogVHJhbnNmb3JtZXJEZWNvZGVyT3B0aW9uc1xuICApOiBbVGVuc29yMUR8VGVuc29yMkQsIFRlbnNvcjFEfFRlbnNvcjJELCBUZW5zb3IxRHxUZW5zb3IyRF0ge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgYE5vdCBpbXBsZW1lbnRlZCB5ZXQuIFVzZXMgJHt0aGlzLmNvbXB1dGVTZWxmQXR0ZW50aW9uTWFza31gKTtcbiAgfVxuXG4gIHByaXZhdGUgY29tcHV0ZVNlbGZBdHRlbnRpb25NYXNrKFxuICAgIGRlY29kZXJTZXF1ZW5jZTogVGVuc29yLFxuICAgIGRlY29kZXJQYWRkaW5nTWFzazogVGVuc29yLFxuICAgIGRlY29kZXJBdHRlbnRpb25NYXNrOiBUZW5zb3IsXG4gICAgdXNlQ2FzdWFsTWFzazogYm9vbGVhbixcbiAgICBzZWxmQXR0ZW50aW9uQ2FjaGU6IFRlbnNvcixcbiAgICBzZWxmQXR0ZW50aW9uQ2FjaGVVcGRhdGVJbmRleDogbnVtYmVyfFRlbnNvclxuICApOiBUZW5zb3Ige1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgeWV0LmApO1xuICB9XG5cbiAgb3ZlcnJpZGUgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCB5ZXQuYCk7XG4gIH1cblxuICBvdmVycmlkZSBjb21wdXRlT3V0cHV0U2hhcGUoZGVjb2RlclNlcXVlbmNlU2hhcGU6IFNoYXBlKTogU2hhcGUge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgeWV0LmApO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVHJhbnNmb3JtZXJEZWNvZGVyKTtcbiJdfQ==