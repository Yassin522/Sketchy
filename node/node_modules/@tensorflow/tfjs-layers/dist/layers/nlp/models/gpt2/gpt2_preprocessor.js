/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * GPT-2 preprocessor layer.
 */
/* Original source: keras-nlp/models/gpt2/gpt2_preprocessor.py */
import { serialization, tidy } from '@tensorflow/tfjs-core';
import { Preprocessor } from '../preprocessor';
import { GPT2Tokenizer } from './gpt2_tokenizer';
import { StartEndPacker } from '../../preprocessing/start_end_packer';
import { ValueError } from '../../../../errors';
function packXYSampleWeight(x, y, sampleWeight) {
    if (y === undefined) {
        return x;
    }
    else if (sampleWeight === undefined) {
        return [x, y];
    }
    else {
        return [x, y, sampleWeight];
    }
}
/**
 * GPT2 preprocessing layer which tokenizes and packs inputs.
 *
 * This preprocessing layer will do 2 things:
 *
 * - Tokenize the inputs using the `tokenizer`.
 * - Construct a dictionary with keys `"tokenIds"`, `"paddingMask"`, that can
 *     be passed directly to a `GPT2Backbone`.
 *
 * The call method of this layer accepts three arguments, `x`, `y`, and
 * `sampleWeight`. `x` can be a string or tensor representing a single
 * segment, a list of strings representing a batch of single segments,
 * or a list of tensors representing multiple segments to be packed together.
 * `y` and `sampleWeight` are both optional, can have any format, and will be
 * passed through unaltered.
 *
 * `GPT2Preprocessor` forces the input to have only one segment, as GPT2 is
 * mainly used for generation tasks. For tasks having multi-segment inputs
 * like "glue/mnli", please use a model designed for classification purposes
 * such as BERT or RoBERTa.
 *
 * Examples:
 *
 * Directly calling the layer on data.
 * ```js
 * const features =  ['a quick fox.', 'a fox quick.'];
 * const vocabulary =
 *    new Map([['<|endoftext|>', 0], ['a', 4], ['Ġquick', 5], ['Ġfox', 6]]);
 * const merges =
 *    ['Ġ q', 'u i', 'c k', 'ui ck', 'Ġq uick', 'Ġ f', 'o x', 'Ġf ox'];
 * const tokenizer = GPT2Tokenizer({vocabulary, merges});
 *
 * const preprocessor = GPT2Preprocessor({tokenizer});
 * preprocessor.call(tensor(['the quick brown fox jumped.']))[0].print();
 * ```
 */
export class GPT2Preprocessor extends Preprocessor {
    constructor(args) {
        var _a, _b, _c;
        super(args);
        this.tokenizer = args.tokenizer;
        this.sequenceLength = (_a = args.sequenceLength) !== null && _a !== void 0 ? _a : 1024;
        this.addStartToken = (_b = args.addStartToken) !== null && _b !== void 0 ? _b : true;
        this.addEndToken = (_c = args.addEndToken) !== null && _c !== void 0 ? _c : true;
        const gpt2Tokenizer = this.tokenizer;
        this.packer = new StartEndPacker({
            startValue: gpt2Tokenizer.startTokenId,
            endValue: gpt2Tokenizer.endTokenId,
            padValue: gpt2Tokenizer.padTokenId,
            sequenceLength: this.sequenceLength,
        });
    }
    getConfig() {
        const config = {
            sequenceLength: this.sequenceLength,
            addStartToken: this.addStartToken,
            addEndToken: this.addEndToken,
        };
        const baseConfig = super.getConfig();
        Object.assign(config, baseConfig);
        return config;
    }
    call(inputs, kwargs) {
        return this.callAndReturnPaddingMask(inputs, kwargs).tokenIds;
    }
    callAndReturnPaddingMask(inputs, kwargs) {
        return tidy(() => {
            var _a;
            if (inputs instanceof Array) {
                if (inputs.length !== 1) {
                    throw new ValueError('GPT2 requires each input feature to contain only ' +
                        `one segment, but received ${inputs.length}. If you are using ` +
                        'GPT2 for a multi-segment classification task, please refer to ' +
                        'classification models like BERT or RoBERTa.');
                }
                inputs = inputs[0];
            }
            const sequenceLength = (_a = kwargs.sequenceLength) !== null && _a !== void 0 ? _a : this.sequenceLength;
            const [tokenIds, paddingMask] = this.packer.callAndReturnPaddingMask(this.tokenizer.call(inputs), {
                sequenceLength,
                addStartValue: this.addStartToken,
                addEndValue: this.addEndToken
            });
            return {
                tokenIds: tokenIds,
                paddingMask: paddingMask
            };
        });
    }
    /**
     * Calls the layer and returns extra information like the paddingMask used to
     * pack the sequence, the label data, and the sample weights used.
     */
    callAndPackArgs(inputs, kwargs) {
        const x = this.callAndReturnPaddingMask(inputs, kwargs);
        return packXYSampleWeight(x, kwargs.y, kwargs.sampleWeight);
    }
    static tokenizerCls(cls) {
        return GPT2Tokenizer;
    }
}
serialization.registerClass(GPT2Preprocessor);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3B0Ml9wcmVwcm9jZXNzb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL25scC9tb2RlbHMvZ3B0Mi9ncHQyX3ByZXByb2Nlc3Nvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSDs7R0FFRztBQUVILGlFQUFpRTtBQUNqRSxPQUFPLEVBQW9CLGFBQWEsRUFBRSxJQUFJLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUc5RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUN0RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFtRGhELFNBQVMsa0JBQWtCLENBQ3pCLENBQXNCLEVBQUUsQ0FBVSxFQUFFLFlBQXFCO0lBS3pELElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtRQUNuQixPQUFPLENBQUMsQ0FBQztLQUNWO1NBQU0sSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO1FBQ3JDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDZjtTQUFNO1FBQ0wsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDN0I7QUFDSCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUNHO0FBQ0gsTUFBTSxPQUFPLGdCQUFpQixTQUFRLFlBQVk7SUFNaEQsWUFBWSxJQUEwQjs7UUFDcEMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxj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ICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEdQVC0yIHByZXByb2Nlc3NvciBsYXllci5cbiAqL1xuXG4vKiBPcmlnaW5hbCBzb3VyY2U6IGtlcmFzLW5scC9tb2RlbHMvZ3B0Mi9ncHQyX3ByZXByb2Nlc3Nvci5weSAqL1xuaW1wb3J0IHsgVGVuc29yLCBUZW5zb3IyRCwgc2VyaWFsaXphdGlvbiwgdGlkeSB9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7IExheWVyQXJncyB9IGZyb20gJy4uLy4uLy4uLy4uL2VuZ2luZS90b3BvbG9neSc7XG5pbXBvcnQgeyBQcmVwcm9jZXNzb3IgfSBmcm9tICcuLi9wcmVwcm9jZXNzb3InO1xuaW1wb3J0IHsgR1BUMlRva2VuaXplciB9IGZyb20gJy4vZ3B0Ml90b2tlbml6ZXInO1xuaW1wb3J0IHsgU3RhcnRFbmRQYWNrZXIgfSBmcm9tICcuLi8uLi9wcmVwcm9jZXNzaW5nL3N0YXJ0X2VuZF9wYWNrZXInO1xuaW1wb3J0IHsgVmFsdWVFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uL2Vycm9ycyc7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBHUFQyUHJlcHJvY2Vzc29yQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBBIEdQVDJUb2tlbml6ZXIgaW5zdGFuY2UuXG4gICAqL1xuICB0b2tlbml6ZXI6IEdQVDJUb2tlbml6ZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIHBhY2tlZCBpbnB1dHMuXG4gICAqIERlZmF1bHRzIHRvIDEwMjQuXG4gICAqL1xuICBzZXF1ZW5jZUxlbmd0aD86IG51bWJlcjtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcHJlcHJvY2Vzc29yIHdpbGwgcHJlcGVuZCB0aGUgdG9rZW5pemVyIHN0YXJ0IHRva2VuIHRvIGVhY2hcbiAgICogaW5wdXQgc2VxdWVuY2UuXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGFkZFN0YXJ0VG9rZW4/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBwcmVwcm9jZXNzb3Igd2lsbCBwcmVwZW5kIHRoZSB0b2tlbml6ZXIgZW5kIHRva2VuIHRvIGVhY2hcbiAgICogaW5wdXQgc2VxdWVuY2UuXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGFkZEVuZFRva2VuPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEdQVDJQcmVwcm9jZXNzb3JPcHRpb25zIHtcbiAgLyoqXG4gICAqIEFueSBsYWJlbCBkYXRhLiBXaWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuYWx0ZXJlZC5cbiAgICovXG4gIHk/OiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIEFueSBsYWJlbCB3ZWlnaHQgZGF0YS4gV2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmFsdGVyZWQuXG4gICAqL1xuICBzYW1wbGVXZWlnaHQ/OiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIFBhc3MgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyZWQgYHNlcXVlbmNlTGVuZ3RoYCBvZiB0aGUgbGF5ZXIuXG4gICAqL1xuICBzZXF1ZW5jZUxlbmd0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFByZXByb2Nlc3Nvck91dHB1dHMge1xuICB0b2tlbklkczogVGVuc29yMkQ7XG4gIHBhZGRpbmdNYXNrOiBUZW5zb3IyRDtcbn1cblxuZnVuY3Rpb24gcGFja1hZU2FtcGxlV2VpZ2h0KFxuICB4OiBQcmVwcm9jZXNzb3JPdXRwdXRzLCB5PzogVGVuc29yLCBzYW1wbGVXZWlnaHQ/OiBUZW5zb3IpOlxuICBQcmVwcm9jZXNzb3JPdXRwdXRzXG4gIHwgW1ByZXByb2Nlc3Nvck91dHB1dHMsIFRlbnNvcl1cbiAgfCBbUHJlcHJvY2Vzc29yT3V0cHV0cywgVGVuc29yLCBUZW5zb3JdIHtcblxuICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHg7XG4gIH0gZWxzZSBpZiAoc2FtcGxlV2VpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbeCwgeSwgc2FtcGxlV2VpZ2h0XTtcbiAgfVxufVxuXG4vKipcbiAqIEdQVDIgcHJlcHJvY2Vzc2luZyBsYXllciB3aGljaCB0b2tlbml6ZXMgYW5kIHBhY2tzIGlucHV0cy5cbiAqXG4gKiBUaGlzIHByZXByb2Nlc3NpbmcgbGF5ZXIgd2lsbCBkbyAyIHRoaW5nczpcbiAqXG4gKiAtIFRva2VuaXplIHRoZSBpbnB1dHMgdXNpbmcgdGhlIGB0b2tlbml6ZXJgLlxuICogLSBDb25zdHJ1Y3QgYSBkaWN0aW9uYXJ5IHdpdGgga2V5cyBgXCJ0b2tlbklkc1wiYCwgYFwicGFkZGluZ01hc2tcImAsIHRoYXQgY2FuXG4gKiAgICAgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIGEgYEdQVDJCYWNrYm9uZWAuXG4gKlxuICogVGhlIGNhbGwgbWV0aG9kIG9mIHRoaXMgbGF5ZXIgYWNjZXB0cyB0aHJlZSBhcmd1bWVudHMsIGB4YCwgYHlgLCBhbmRcbiAqIGBzYW1wbGVXZWlnaHRgLiBgeGAgY2FuIGJlIGEgc3RyaW5nIG9yIHRlbnNvciByZXByZXNlbnRpbmcgYSBzaW5nbGVcbiAqIHNlZ21lbnQsIGEgbGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBhIGJhdGNoIG9mIHNpbmdsZSBzZWdtZW50cyxcbiAqIG9yIGEgbGlzdCBvZiB0ZW5zb3JzIHJlcHJlc2VudGluZyBtdWx0aXBsZSBzZWdtZW50cyB0byBiZSBwYWNrZWQgdG9nZXRoZXIuXG4gKiBgeWAgYW5kIGBzYW1wbGVXZWlnaHRgIGFyZSBib3RoIG9wdGlvbmFsLCBjYW4gaGF2ZSBhbnkgZm9ybWF0LCBhbmQgd2lsbCBiZVxuICogcGFzc2VkIHRocm91Z2ggdW5hbHRlcmVkLlxuICpcbiAqIGBHUFQyUHJlcHJvY2Vzc29yYCBmb3JjZXMgdGhlIGlucHV0IHRvIGhhdmUgb25seSBvbmUgc2VnbWVudCwgYXMgR1BUMiBpc1xuICogbWFpbmx5IHVzZWQgZm9yIGdlbmVyYXRpb24gdGFza3MuIEZvciB0YXNrcyBoYXZpbmcgbXVsdGktc2VnbWVudCBpbnB1dHNcbiAqIGxpa2UgXCJnbHVlL21ubGlcIiwgcGxlYXNlIHVzZSBhIG1vZGVsIGRlc2lnbmVkIGZvciBjbGFzc2lmaWNhdGlvbiBwdXJwb3Nlc1xuICogc3VjaCBhcyBCRVJUIG9yIFJvQkVSVGEuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogRGlyZWN0bHkgY2FsbGluZyB0aGUgbGF5ZXIgb24gZGF0YS5cbiAqIGBgYGpzXG4gKiBjb25zdCBmZWF0dXJlcyA9ICBbJ2EgcXVpY2sgZm94LicsICdhIGZveCBxdWljay4nXTtcbiAqIGNvbnN0IHZvY2FidWxhcnkgPVxuICogICAgbmV3IE1hcChbWyc8fGVuZG9mdGV4dHw+JywgMF0sIFsnYScsIDRdLCBbJ8SgcXVpY2snLCA1XSwgWyfEoGZveCcsIDZdXSk7XG4gKiBjb25zdCBtZXJnZXMgPVxuICogICAgWyfEoCBxJywgJ3UgaScsICdjIGsnLCAndWkgY2snLCAnxKBxIHVpY2snLCAnxKAgZicsICdvIHgnLCAnxKBmIG94J107XG4gKiBjb25zdCB0b2tlbml6ZXIgPSBHUFQyVG9rZW5pemVyKHt2b2NhYnVsYXJ5LCBtZXJnZXN9KTtcbiAqXG4gKiBjb25zdCBwcmVwcm9jZXNzb3IgPSBHUFQyUHJlcHJvY2Vzc29yKHt0b2tlbml6ZXJ9KTtcbiAqIHByZXByb2Nlc3Nvci5jYWxsKHRlbnNvcihbJ3RoZSBxdWljayBicm93biBmb3gganVtcGVkLiddKSlbMF0ucHJpbnQoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR1BUMlByZXByb2Nlc3NvciBleHRlbmRzIFByZXByb2Nlc3NvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBhZGRTdGFydFRva2VuOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IGFkZEVuZFRva2VuOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhY2tlcjogU3RhcnRFbmRQYWNrZXI7XG5cbiAgY29uc3RydWN0b3IoYXJnczogR1BUMlByZXByb2Nlc3NvckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLnRva2VuaXplciA9IGFyZ3MudG9rZW5pemVyO1xuICAgIHRoaXMuc2VxdWVuY2VMZW5ndGggPSBhcmdzLnNlcXVlbmNlTGVuZ3RoID8/IDEwMjQ7XG4gICAgdGhpcy5hZGRTdGFydFRva2VuID0gYXJncy5hZGRTdGFydFRva2VuID8/IHRydWU7XG4gICAgdGhpcy5hZGRFbmRUb2tlbiA9IGFyZ3MuYWRkRW5kVG9rZW4gPz8gdHJ1ZTtcblxuICAgIGNvbnN0IGdwdDJUb2tlbml6ZXIgPSB0aGlzLnRva2VuaXplciBhcyBHUFQyVG9rZW5pemVyO1xuICAgIHRoaXMucGFja2VyID0gbmV3IFN0YXJ0RW5kUGFja2VyKHtcbiAgICAgIHN0YXJ0VmFsdWU6IGdwdDJUb2tlbml6ZXIuc3RhcnRUb2tlbklkLFxuICAgICAgZW5kVmFsdWU6IGdwdDJUb2tlbml6ZXIuZW5kVG9rZW5JZCxcbiAgICAgIHBhZFZhbHVlOiBncHQyVG9rZW5pemVyLnBhZFRva2VuSWQsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogdGhpcy5zZXF1ZW5jZUxlbmd0aCxcbiAgICB9KTtcbiAgfVxuXG4gIG92ZXJyaWRlIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHNlcXVlbmNlTGVuZ3RoOiB0aGlzLnNlcXVlbmNlTGVuZ3RoLFxuICAgICAgYWRkU3RhcnRUb2tlbjogdGhpcy5hZGRTdGFydFRva2VuLFxuICAgICAgYWRkRW5kVG9rZW46IHRoaXMuYWRkRW5kVG9rZW4sXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBvdmVycmlkZSBjYWxsKFxuICAgIGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEdQVDJQcmVwcm9jZXNzb3JPcHRpb25zKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsQW5kUmV0dXJuUGFkZGluZ01hc2soaW5wdXRzLCBrd2FyZ3MpLnRva2VuSWRzO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxsQW5kUmV0dXJuUGFkZGluZ01hc2soXG4gICAgaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sXG4gICAga3dhcmdzOiBHUFQyUHJlcHJvY2Vzc29yT3B0aW9uc1xuICApOiBQcmVwcm9jZXNzb3JPdXRwdXRzIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpZiAoaW5wdXRzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICdHUFQyIHJlcXVpcmVzIGVhY2ggaW5wdXQgZmVhdHVyZSB0byBjb250YWluIG9ubHkgJyArXG4gICAgICAgICAgICBgb25lIHNlZ21lbnQsIGJ1dCByZWNlaXZlZCAke2lucHV0cy5sZW5ndGh9LiBJZiB5b3UgYXJlIHVzaW5nIGAgK1xuICAgICAgICAgICAgJ0dQVDIgZm9yIGEgbXVsdGktc2VnbWVudCBjbGFzc2lmaWNhdGlvbiB0YXNrLCBwbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICAgICAnY2xhc3NpZmljYXRpb24gbW9kZWxzIGxpa2UgQkVSVCBvciBSb0JFUlRhLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0cyA9IGlucHV0c1swXTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBrd2FyZ3Muc2VxdWVuY2VMZW5ndGggPz8gdGhpcy5zZXF1ZW5jZUxlbmd0aDtcbiAgICAgIGNvbnN0IFt0b2tlbklkcywgcGFkZGluZ01hc2tdID0gdGhpcy5wYWNrZXIuY2FsbEFuZFJldHVyblBhZGRpbmdNYXNrKFxuICAgICAgICB0aGlzLnRva2VuaXplci5jYWxsKGlucHV0cyksXG4gICAgICAgIHtcbiAgICAgICAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICAgICAgICBhZGRTdGFydFZhbHVlOiB0aGlzLmFkZFN0YXJ0VG9rZW4sXG4gICAgICAgICAgYWRkRW5kVmFsdWU6IHRoaXMuYWRkRW5kVG9rZW5cbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5JZHM6IHRva2VuSWRzIGFzIFRlbnNvcjJELFxuICAgICAgICBwYWRkaW5nTWFzazogcGFkZGluZ01hc2sgYXMgVGVuc29yMkRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIGxheWVyIGFuZCByZXR1cm5zIGV4dHJhIGluZm9ybWF0aW9uIGxpa2UgdGhlIHBhZGRpbmdNYXNrIHVzZWQgdG9cbiAgICogcGFjayB0aGUgc2VxdWVuY2UsIHRoZSBsYWJlbCBkYXRhLCBhbmQgdGhlIHNhbXBsZSB3ZWlnaHRzIHVzZWQuXG4gICAqL1xuICBjYWxsQW5kUGFja0FyZ3MoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogR1BUMlByZXByb2Nlc3Nvck9wdGlvbnMpOlxuICAgIFByZXByb2Nlc3Nvck91dHB1dHNcbiAgICB8IFtQcmVwcm9jZXNzb3JPdXRwdXRzLCBUZW5zb3JdXG4gICAgfCBbUHJlcHJvY2Vzc29yT3V0cHV0cywgVGVuc29yLCBUZW5zb3JdIHtcbiAgICBjb25zdCB4ID0gdGhpcy5jYWxsQW5kUmV0dXJuUGFkZGluZ01hc2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgIHJldHVybiBwYWNrWFlTYW1wbGVXZWlnaHQoeCwga3dhcmdzLnksIGt3YXJncy5zYW1wbGVXZWlnaHQpO1xuICB9XG5cbiAgc3RhdGljIG92ZXJyaWRlIHRva2VuaXplckNsczxUIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGU+KFxuICAgIGNsczogc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGVDb25zdHJ1Y3RvcjxUPikge1xuICAgIHJldHVybiBHUFQyVG9rZW5pemVyO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR1BUMlByZXByb2Nlc3Nvcik7XG4iXX0=