/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { tensorScatterUpdate, tidy } from '@tensorflow/tfjs-core';
export function tensorToArr(input) {
    return Array.from(input.dataSync());
}
export function tensorArrTo2DArr(inputs) {
    return inputs.map(input => tensorToArr(input));
}
/**
 * Returns a new Tensor with `updates` inserted into `inputs` starting at the
 * index `startIndices`.
 *
 * @param inputs Tensor to "modify"
 * @param startIndices the starting index to insert the slice.
 *  Length must be equal to `inputs.rank`;
 * @param updates the update tensor. Shape must fit within `inputs` shape.
 * @returns a new tensor with the modification.
 */
export function sliceUpdate(inputs, startIndices, updates) {
    return tidy(() => {
        const indices = [];
        /**
         * Computes the update indices by iterating through all indices from
         * `startIndices` to `startIndices + updates.shape`.
         */
        function createIndices(idx, curr) {
            if (curr.length === startIndices.length) {
                indices.push(curr.slice());
                return;
            }
            const start = startIndices[idx];
            const end = start + updates.shape[idx];
            for (let i = start; i < end; i++) {
                curr.push(i);
                createIndices(idx + 1, curr);
                curr.pop();
            }
        }
        createIndices(0, []);
        // Flatten the updates to match length of its update indices.
        updates = updates.reshape([updates.size]);
        return tensorScatterUpdate(inputs, indices, updates);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL25scC91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQVUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFMUUsTUFBTSxVQUFVLFdBQVcsQ0FBQyxLQUFhO0lBQ3ZDLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQXlCLENBQUM7QUFDOUQsQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxNQUFnQjtJQUMvQyxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNqRCxDQUFDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FDdkIsTUFBYyxFQUFFLFlBQXNCLEVBQUUsT0FBZTtJQUN6RCxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDZixNQUFNLE9BQU8sR0FBZSxFQUFFLENBQUM7UUFDL0I7OztXQUdHO1FBQ0gsU0FBUyxhQUFhLENBQUMsR0FBVyxFQUFFLElBQWM7WUFDaEQsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLFlBQVksQ0FBQyxNQUFNLEVBQUU7Z0JBQ3ZDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQzNCLE9BQU87YUFDUjtZQUNELE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoQyxNQUFNLEdBQUcsR0FBRyxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN2QyxLQUFLLElBQUksQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNiLGFBQWEsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUM3QixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDWjtRQUNILENBQUM7UUFDRCxhQUFhLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3JCLDZEQUE2RDtRQUM3RCxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFDLE9BQU8sbUJBQW1CLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7IFRlbnNvciwgdGVuc29yU2NhdHRlclVwZGF0ZSwgdGlkeSB9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW5zb3JUb0FycihpbnB1dDogVGVuc29yKTogdW5rbm93bltdIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oaW5wdXQuZGF0YVN5bmMoKSkgYXMgdW5rbm93biBhcyB1bmtub3duW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW5zb3JBcnJUbzJEQXJyKGlucHV0czogVGVuc29yW10pOiB1bmtub3duW11bXSB7XG4gIHJldHVybiBpbnB1dHMubWFwKGlucHV0ID0+IHRlbnNvclRvQXJyKGlucHV0KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBUZW5zb3Igd2l0aCBgdXBkYXRlc2AgaW5zZXJ0ZWQgaW50byBgaW5wdXRzYCBzdGFydGluZyBhdCB0aGVcbiAqIGluZGV4IGBzdGFydEluZGljZXNgLlxuICpcbiAqIEBwYXJhbSBpbnB1dHMgVGVuc29yIHRvIFwibW9kaWZ5XCJcbiAqIEBwYXJhbSBzdGFydEluZGljZXMgdGhlIHN0YXJ0aW5nIGluZGV4IHRvIGluc2VydCB0aGUgc2xpY2UuXG4gKiAgTGVuZ3RoIG11c3QgYmUgZXF1YWwgdG8gYGlucHV0cy5yYW5rYDtcbiAqIEBwYXJhbSB1cGRhdGVzIHRoZSB1cGRhdGUgdGVuc29yLiBTaGFwZSBtdXN0IGZpdCB3aXRoaW4gYGlucHV0c2Agc2hhcGUuXG4gKiBAcmV0dXJucyBhIG5ldyB0ZW5zb3Igd2l0aCB0aGUgbW9kaWZpY2F0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VVcGRhdGUoXG4gICAgaW5wdXRzOiBUZW5zb3IsIHN0YXJ0SW5kaWNlczogbnVtYmVyW10sIHVwZGF0ZXM6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBpbmRpY2VzOiBudW1iZXJbXVtdID0gW107XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHVwZGF0ZSBpbmRpY2VzIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBpbmRpY2VzIGZyb21cbiAgICAgKiBgc3RhcnRJbmRpY2VzYCB0byBgc3RhcnRJbmRpY2VzICsgdXBkYXRlcy5zaGFwZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5kaWNlcyhpZHg6IG51bWJlciwgY3VycjogbnVtYmVyW10pOiB2b2lkIHtcbiAgICAgIGlmIChjdXJyLmxlbmd0aCA9PT0gc3RhcnRJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goY3Vyci5zbGljZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydEluZGljZXNbaWR4XTtcbiAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdXBkYXRlcy5zaGFwZVtpZHhdO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgY3Vyci5wdXNoKGkpO1xuICAgICAgICBjcmVhdGVJbmRpY2VzKGlkeCArIDEsIGN1cnIpO1xuICAgICAgICBjdXJyLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVJbmRpY2VzKDAsIFtdKTtcbiAgICAvLyBGbGF0dGVuIHRoZSB1cGRhdGVzIHRvIG1hdGNoIGxlbmd0aCBvZiBpdHMgdXBkYXRlIGluZGljZXMuXG4gICAgdXBkYXRlcyA9IHVwZGF0ZXMucmVzaGFwZShbdXBkYXRlcy5zaXplXSk7XG4gICAgcmV0dXJuIHRlbnNvclNjYXR0ZXJVcGRhdGUoaW5wdXRzLCBpbmRpY2VzLCB1cGRhdGVzKTtcbiAgfSk7XG59XG4iXX0=